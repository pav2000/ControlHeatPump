/*
 * Copyright (c) 2016-2023 by Pavel Panfilov <firstlast2007@gmail.com> skype pav2000pav
 * &                       by Vadim Kulakov vad7@yahoo.com, vad711
 * "Народный контроллер" для тепловых насосов.
 * Данное програмное обеспечение предназначено для управления
 * различными типами тепловых насосов для отопления и ГВС.
 *
 * This file is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 3.0 of the License, or (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 */ 

#ifndef Config_h
#define Config_h
#include "SCharts.h"
#include <Ethernet.h>                       // Нужна для определения SPI_RATE в w5100.h

// --------------------------------------------------------------------------------
// КОНФИГУРАЦИИ ТН ----------------------------------------------------------------
// --------------------------------------------------------------------------------
// Конфигурации - может быть только одна!!
// Раскоментируйте нужную конфигурацию  и закоментируйте не нужную.
//#define CONFIG_1		// УФА  Старт-стоп компрессор с ЭВИ (АС три фазы) ЭРВ с датчиком Р, РТО, переливная схема
//#define CONFIG_2		// sheeny   Воздушный Старт стоп  с шаговым ЭРВ, РТО и датчиком давления испарителя
//#define CONFIG_3		// dimex    инвертор+ЭРВ + с РТО и датчиком давления испарителя
//#define CONFIG_4		// dobrinia инвертор+ЭРВ + с РТО и датчиком давления испарителя
#define CONFIG_5		// pav2000inv  Инвертор BLDC с шаговым ЭРВ и РТО
//#define CONFIG_6		// NTC      Частотник PWM, 1 фаза, 4 реле, ЭРВ, NTC
//#define CONFIG_7		// vad7     Частотник Vacon, 3 фазы, ЭРВ, РТО, 2 датчика давления


// -----------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------- МОЙ ОСНОВНОЙ КОНФИГ -----------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------
// =============================================== C O N F I G   5 ===================================================================
// -----------------------------------------------------------------------------------------------------------------------------------
#ifdef CONFIG_5    // Имя и описание конфигурации и ОСОБЕННОСТИ конфигурации ---------------------------------------------------------
 //   #define DEMO                                                              // Включение демо режима
    #define CONFIG_NAME   "pav2000inv"                                        // Имя конфигурации
    #define CONFIG_NOTE   "Инвертор с компрессором BLDC с шаговым ЭРВ и РТО"  // Описание конфигурации
    #define HP_SCHEME       2                                                 // Номер схемы который выводится на морде, подмена файлов plan[HPscheme].png -> plan1.png
	#define DEBUG                                                             // В последовательный порт шлет сообщения в первую очередь ошибки
//	#define DEBUG_NATIVE_USB		                                          // Отладка через второй USB порт (Native)
	#define DEBUG_MODWORK                                                     // Вывод в консоль состояние HP при работе
//	#define DEBUG_PID				                                          // Отладка ПИДа
	#define NEXTION                                                           // Разрешить использование дисплея ЗАКОМЕНТИРУЙТЕ эту строку что бы не использовать дисплей
    #ifdef 	NEXTION
        //#define NEXTION_DEBUG                                               // Выводить информацию в отладочный порт с дисплея
    	#define NEXTION_GENERATOR                                             // Показ на nextion кнопки "Работа от генератора" (ограничение мощности потребления)
//    	#define NEXTION_SCR0_DIS_ON_OFF	// Отключить реакцию на кнопку Вкл/Выкл на главном экране, еще одна кнопка Вкл/Выкл на экране Профили.
    #endif  
    uint8_t SPI_RATE 	 = 2;	                                              // делитель для SPI шины, (2=42MHz, 3=28MHz, 4=21MHz) единый для ВСЕХ устройств
	#define SD_CLOCK     30	                                                  // частота SPI для SD карты в МГц (работало 28)
 //   #define DEFROST                                                         // нужна разморозка
         #define ONEWIRE_DS2482                                               // Использование мастера i2c Onewire DS2482 (адрес AD0 = 0)
   //    #define ONEWIRE_DS2482_SECOND                                        // второй мастер i2 Onewire DS2482 (адрес AD0 = 1)
   //    #define ONEWIRE_DS2482_2WAY 		                                  // 2-х проводный OneWire второго мастера (паразитное питание)
   //	 #ifdef ONEWIRE_DS2482_2WAY
   	   const uint8_t ONEWIRE_2WAY = 0b0000; // На каких шинах (4,3,2,1) двух-проводные датчики, битовая маска
   //	 #endif
        #define NO_SD_CONTROL                                                 // Использование выхода для контроля вставленной SD карты
        #define SPI_FLASH                                                     // Наличие чипа флеш памяти на шине SPI
        #define DRV_EEV_L9333                                                 // Драйвера ЭРВ L9333  диагностика
        #define KEY_ON_OFF                                                    // KEY1 Наличие кнопки включения и переключения в safeNetwork (нажата при сбросе)
        #define LOAD_VERIFICATION                                             // Признак чтения настроек c проверкой версии, длины, CRC16. Закоментируйте эту строку для ПОПЫТКИ загрузить старый формат, Запись всегда идет в новом
        #define MODBUS_TIME_TRANSMISION 1                                     // Пауза (msec) между запросом и ответом по модбас было 4
        
        //  I2C память ---------------------------------------------------------------
        #define I2C_EEPROM_64KB                                               // Использование памяти I2C для записи журнала при коментарии используется оперативка
        #ifdef DEMO                                                           // Для удобства переключения между демо и боевым вариантом
           #define I2C_FRAM_MEMORY       1                                    // Тип используемой памяти 0 - Флеш; 1  - FRAM память // У меня на демо стоит FRAM 128 кб
        #else
           #define I2C_FRAM_MEMORY       0                                    // Тип используемой памяти 0 - Флеш; 1  - FRAM память // На рабочем контроллере стоит обычная флеш 64 кб
        #endif
		#ifdef  I2C_EEPROM_64KB                    // В зависимости от типа чипа
			#define I2C_ADR_EEPROM    0x50         // Адрес чипа eeprom на шине I2C
			#define I2C_SIZE_EEPROM    512    	   // Объем чипа в килобитах (vad711: FM24V10 - это фактически два чипа разделенные пином, в библиотеке exteeprom сквозная нумерация: 65536+ другая страница)
			#ifdef DEMO
			  #define I2C_MEMORY_TOTAL   1024      // FRAM Итоговый размер I2C памяти в килобитах
			#else
			  #define I2C_MEMORY_TOTAL   512       // FLASH Итоговый размер I2C памяти в килобитах
			#endif
			#define I2C_PAGE_EEPROM     64         // Размер страницы для чтения eeprom байты
		#else // все остальное
			#define I2C_ADR_EEPROM    0x57         // Адрес чипа eeprom на шине I2C
			#define I2C_SIZE_EEPROM   32	       // Объем чипа eeprom в килобитах
			#define I2C_PAGE_EEPROM   32           // Размер страницы для чтения eeprom байты
			#define I2C_MEMORY_TOTAL  I2C_SIZE_EEPROM // Итоговый размер I2C памяти
		#endif
		
	  	// SDM счетчик  ------------------------------------------------------------------------
         #define USE_ELECTROMETER_SDM               // Наличие счетчика SDM120 в конфигурации
         #define SDM_BLOCK                          // Блокировать чтение счетчика при потере связи, в противном случае будут переодически делаться попытки воссановить связь
         // Защиты по входному напряжению. Используется счетчик SDM*
         #define SDM_MIN_VOLTAGE     170.0          // Минимальное напряжение работы ТН при падении - предупреждение
         #define SDM_MAX_VOLTAGE     250.0          // Максимальное напряжение работы ТН при падении - выключение ТН
         #define SDM_MAX_POWER       2500.0         // Максимальная мощность потребления (ватт) - выключение ТН
   
    
		// Питание, АЦП ИБП ---------------------------------------------------------------
		#define EXTERNAL_AREF                       // Использование внешней опоры для АЦП (ADR4525ARZ) требует доработки DUE и поддержки платы
		#ifdef EXTERNAL_AREF                        // Какая опора для АЦП используется
		   #define SAM3X_ADC_REF  2.5006            // Используется внешняя опора ADR4525ARZ плата pav2000 (UT71E результататы ЗИП 2.4997 ТН 2.5006)
		#else
		   #define SAM3X_ADC_REF  3.30              // Штатное подключение используется питание DUE
		#endif
		#define POWER_CONTROL                       // Использование выхода для управления питанием платы (можно сбросить все кроме контроллера)
		#define VCC_CONTROL                         // Контроль за питанием контрола (прямое чтение) смотреть ADC_VCC и K_VCC_POWER
		// #define USE_UPS					        // Используется ИБП на контроллер, проверка через вход SPOWER
		// #define STATS_USE_BUFFER_FOR_SAVING      // Сохранять статистику только когда буфер (512 байт) заполнен, иначе каждый день
 
      // FREE RTOS  Размеры стеков задач в словах (4 байта) -----------------------------------------------
     #define STACK_vUpdateCommand  180             // 160 Стек задачи выполнение команд управления (разбор очереди комманд)
     #define STACK_vWebX           170             // 230 Стек задачи веб морды один поток (потоков может быть 1-4) 180 рабоатет

     // Настройки веб морды --------------------------------------------------------------
  // #define CHART_ONLY_COMP_ON               // Накопление точек для графиков ТОЛЬКО если компрессор работает, иначе всегда (и в паузах тоже) когда ТН включен
     #define CLEAR_CHART_HP_ON                // очистка графиков при страте ТН
  // #define COP_ALL_CALC                     // Проводить расчет КОП всегда, если дефайна нет то КОП считается ТОЛЬКО при работающем компрессоре, в паузах ставится 0
     #define WEB_STATUS_SHOW_VERSION	      // Показывать версию в строке статуса (запрос get_status)
     #define WEB_STATUS_SHOW_OVERHEAT    	  // Показывать перегрев в строке статуса (запрос get_status)
     #define CHART_POINT       400            // Максимальное число точек графика //360 - работает, смотрим свободную память!

     // СЕТЕВЫЕ НАСТРОЙКИ --------------------------------------------------------------
     #define W5200_THREAD         4              // Число потоков для сетевого чипа w5200 допустимо 1-4 потока, на 4 скорее всего не хватить места в оперативке
	 #define MQTT                                  // признак использования MQTT при неиспользовании необходимо закоментировать
	 const IPAddress defaultIP(192, 168, 0, 177);
     const IPAddress defaultSDNS(192, 168, 0, 191);
     const IPAddress defaultGateway(192, 168, 0, 1);
     const IPAddress defaultSubnet(255, 255, 255, 0);
     const boolean  defaultDHCP=false;              
	
    // Временные задержки/времена  начала дефайна в конфиге начинается DELAY  в константах начинается с TIME
    #define DEF_DELAY_ON_PUMP           60       // Задержка включения компрессора после включения насосов (сек).
    #define DEF_DELAY_OFF_PUMP          60       // Задержка выключения насосов после выключения компрессора (сек).
    #define DEF_DELAY_START_RES        (5*60)    // Задержка включения ТН после внезапного сброса контроллера (сек.)
    #define DEF_DELAY_REPEAD_START     (10*60)   // Задержка перед повторным включениме ТН при ошибке (попытки пуска) секунды
    #define DEF_DELAY_DEFROST_ON        120      // ДЛЯ ВОЗДУШНОГО ТН Задержка после срабатывания датчика перед включением разморозки (секунды)
    #define DEF_DELAY_DEFROST_OFF       120      // ДЛЯ ВОЗДУШНОГО ТН Задержка перед выключением разморозки (секунды)
    #define DEF_DELAY_R4WAY             120      // Задержка между переключением 4-х ходового клапана и включением компрессора, для выравнивания давлений (сек). Если включены эти опции (переключение тепло-холод)
    #define DEF_DELAY_BOILER_SW         60       // Пауза (сек) после переключение ГВС - выравниваем температуру в контуре отопления/ГВС что бы сразу защиты не сработали
    #define DEF_DELAY_BOILER_OFF        120      // Время (сек) на сколько блокируются защиты при переходе с ГВС на отопление и охлаждение слишком горяче после ГВС
	#define DELAY_AFTER_SWITCH_RELAY	500	     // Задержка после переключения реле, для сглаживания потребления и уменьшения помех(мс)
	#define DELAY_BEFORE_STOP_IN_PUMP	10		 // Задержка перед выключением насоса геоконтура, насос отопления отключается позже (сек)
           
    // --------------------------------------------------------------------------------
    // ЖЕЛЕЗО  - привязка к ногам контроллера  В зависимости от конкретной схемы и платы
    // Для каждой конфигурации теперь свои определения!!!
    // --------------------------------------------------------------------------------
    // SPI шина управление отдельными устройствами до 3-х устройств (активный уровень низкий)
    #define PIN_SPI_CS_W5XXX   10       // ++ ETH-CS   сигнал CS управление сетевым чипом w5500
    #define PIN_SPI_CS_SD      4        // ++ SD-CS    сигнал CS управление SD картой
    #define PIN_SPI_CS_FLASH   52       // ++ FLASH-CS сигнал CS управление чипом флеш памяти (32 мБит)
    // Сервис
    #define PIN_ETH_RES         8       // ++ ETH-RES Сброс сетевого чипа w5500 активный low нормально high
    #define PIN_ETH_INT         9       // ++ ETH-INT Прерывание с w5500 пока не используется надо програмиировать на вход
    #define PIN_ETH_CS         10       // ++ ETH-CS Чип селект SPI w5500
    #define PIN_LED1           38       // ++ LED1 Первый красный светодиод для контроля (питание и фатальная ошибка freeRTOS)
    #define PIN_LED_OK         39       // ++ LED2 Второй зеленый светодиод Выход на светодиод мигает 0.5 герца - ОК  с частотой 2 герца ошибка
    #define PIN_KEY1           40       // ++ KEY1 Первая кнопка (ТН вкл/вкл) Нажатие при включении - режим safeNetwork (настрока сети по умолчанию 192.168.0.177  шлюз 192.168.0.1, не спрашивает пароль на вход в веб морду)
    #define PIN_KEY2           41       // +  KEY2 Вторая кнопка
    #define PIN_KEY3           42       // +  KEY3 Третья кнопка
    #ifdef DEMO
       #define PIN_BEEP        88//43   // ++ SOUND Выход на пищалку  88- нога не использующиеся
    #else
       #define PIN_BEEP        43       // ++ SOUND Выход на пищалку  88- нога не использующиеся
    #endif
    #define PIN_STEP_DIAG      44       // ++ STEP-DIAG Контроль драйвера шаговика
    #define PIN_NO_SD_CARD     45       // ++ CD Отсутствие карты в слоте
    #define PIN_POWER_ON       50       // ++ PWR-OFF Включение питания на всю плату (включение LOW)
    #define PIN_ADC_VCC        3        // ++ Нога АЦП куда заводится через делитель напряжение питания (в нумерации sam3x!) в ардуино это А4, коэффициент пересчета K_VCC_POWER

    // EEV куда подключено общий СИНИЙ
    #define PIN_EEV1_D24       24       // ++ первая нога ЭРВ D24  ОРАНЖЕВЫЙ  +А
    #define PIN_EEV2_D25       25       // ++ вторая нога ЭРВ D25  КРАСНЫЙ    +B
    #define PIN_EEV3_D26       26       // ++ третья нога ЭРВ D26  ЖЕЛТЫЙ     -A
    #define PIN_EEV4_D27       27       // ++ четвертая нога ЭРВ D27 ЧЕРНЫЙ   -B

    //Частотный преобразователь
    #define PIN_DEVICE_FC      DAC0     // ++ DAC Аналоговое управление инвертором
    // MODBUS   если закоментировать то это приведет к осутсвию модбаса в конфигурации (работа инвертора и счетчика будет не возможна)
    #define PIN_MODBUS_RSE     22       // +  RS485DE  Управление направлением передачи 485 для связи с инвертором по Modbus (1-передача 0-прием)
        
    // Датчики
    #ifndef ONEWIRE_DS2482
      #define PIN_ONE_WIRE_BUS   23       // ++ 1-W-1 нога с интерфейсом OneWire ВСЕ температурные датчики в зависимости от ключей платы
    #endif
    #define ADC_SENSOR_PEVA    11       // + НОМЕР КАНАЛА ацп (внимание - в нумерации sam3x!) нога куда прицеплен датчик давления PEVA
    #define ADC_SENSOR_PCON    10       // - НОМЕР канала ацп (в нумерации sam3x!) нога куда прицеплен датчик давления PCON
  
    // ---------------------------------------------------------------------------------------------------------------------------------------
    // Контактные датчики ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
    #define INUMBER            3       // Максимальное число контактных датчиков цифровые входы (то что поддерживается)
    //  Ноги куда прицепленны контактные датчики
    #define PIN_SENSOR_SLOWP   32       // ++ DIN1 Датчик низкого давления
    #define PIN_SENSOR_SHIGHP  33       // ++ DIN2 Датчик высокого давления
    #define PIN_SENSOR_SERRFC 34       // ++ DIN3 Сигнал ошибка инвертора
     // Имена индексов ВАЖЕН ПОРЯДОК!
     #define SLOWP             0        // Датчик низкого давления
     #define SHIGHP            1        // Датчик высокого давления
     #define SERRFC            2        // Сигнал ошибка инвертора

      // Массив ног соглано индексов
     const uint8_t pinsInput[INUMBER] = {  PIN_SENSOR_SLOWP,          // ++ DIN1 Датчик низкого давления
                                           PIN_SENSOR_SHIGHP,         // ++ DIN2 Датчик высокого давления
                                           PIN_SENSOR_SERRFC         // ++ DIN3 Сигнал ошибка инвертора
                                         };
      // Описание датчиков
      const char *noteInput[INUMBER] = { "Датчик низкого давления",       // аварийный
                                         "Датчик высокого давления",      // аварийный
                                         "Сигнал ошибки Omron MX2"        // аварийный
                                       };
      // Имена датчиков
      const char *nameInput[INUMBER] = {"SLOWP",            // Датчик низкого давления
                                        "SHIGHP",           // Датчик высокого давления
                                        "SERRFC"           // Сигнал ошибка инвертора
                                       };          
              
     
      const bool TESTINPUT[INUMBER]={true,true,true};                  // Значения датчиков при тестировании  опция TEST
      const bool ALARMINPUT[INUMBER]={false,false,false};              // Значение датчика при аварии  ПРОВЕРИТЬ НА РЕАЛЬНОЕ СООТВЕТВИЕ (актуально только для pALARM )
      const TYPE_SENSOR SENSORTYPE[INUMBER]={pALARM,pALARM,pALARM};    // тип контактного датчика  pALARM, pSENSOR,  pPULSE
      
    // ---------------------------------------------------------------------------------------------------------------------------------------
    // Частотные датчики ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
    #define FNUMBER            1       // Максимальное число частотных датчиков цифровые входы (то что поддерживается) код поддерживает ТРИ датчика максимально
    //  Ноги куда прицепленны контактные датчики
    #define PIN_SENSOR_FLOWCON   35     // - DIN4 Датчик потока по кондесатору
 //   #define PIN_SENSOR_FLOWEVA   36     // - DIN5 Датчик потока по испарителю
 //   #define PIN_SENSOR_FLOWPCON  32     // - DIN6 Датчик протока предконденсатора
     // Имена индексов ВАЖЕН ПОРЯДОК!
     #define FLOWCON        0        // Датчик потока по кондесатору
 //    #define FLOWEVA        1        // Датчик потока по испарителю
 //    #define FLOWPCON       2        // Датчик протока по предконденсатору
      // Массив ног соглано индексов
     const uint8_t pinsFrequency[FNUMBER] = {PIN_SENSOR_FLOWCON       // - DIN4 Датчик потока по кондесатору
 //                                            ,PIN_SENSOR_FLOWEVA        // - DIN5 Датчик потока по испарителю
//                                             PIN_SENSOR_FLOWPCON     // - DIN6 Датчик протока по предконденсатору
                                             };
      // Описание датчиков
      const char *noteFrequency[FNUMBER] = { "Поток через кондесатор (куб/ч)"       // - DIN4 Датчик потока по кондесатору
//                                             ,"Датчик потока по испарителю (куб/ч)"        // - DIN5 Датчик потока по испарителю
//                                             "Датчик протока по предконденсатору"  // - DIN6 Датчик протока по предконденсатору
                                           };
      // Имена датчиков
      const char *nameFrequency[FNUMBER] = { "FLOWCON"                      // Датчик потока по кондесатору
 //                                            ,"FLOWEVA"                       // Датчик потока по кондесатору
 //                                            "FLOWPCON"            // Датчик протока по предконденсатору
                                           };          
              
      const uint16_t TRANSFLOW[FNUMBER]={3675};                    // Коэффициент преобразования частота - поток сотые
      const uint16_t TESTFLOW[FNUMBER]={700};                      // Значения датчиков при тестировании  опция TEST тысячные куба
      const uint16_t MINFLOW[FNUMBER]= {2};                        // МИНИМАЛЬНЫЕ Значения датчиков десятые куба
      #define FLOW_CONTROL							        	  // Контроль потоков через ПТО (актуален если установлены расходомеры)
    
    // ---------------------------------------------------------------------------------------------------------------------------------------
    // Исполнительные устройства (реле и сухие контакты) ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ----------------------------------
    #define RNUMBER            9           // Число исполнительных устройств (всех) 7 силовых 2 - сухих контакта
 //   #define RELAY_INVERT                 // инвертирование реле выходов реле
 //    #define R4WAY_INVERT                 // Инвертирование четырехходового при этом получается: охлаждение - реле выключено, нагрев - включено (если дефайна нет то на оборот)

    // НОГИ Устройства силовые 220 вольт (максимум до 8 штук)
    #define PIN_DEVICE_RCOMP     2        // ++ PWR_ON1 Реле включения компрессора (через инвертор)
    #define PIN_DEVICE_RPUMPI    12       // ++ PWR_ON2 Реле включения насоса входного контура  (геоконтур)
    #define PIN_DEVICE_RPUMPO    13       // ++ PWR_ON3 Реле включения насоса выхордного контура  (отопление и ГВС)
    #define PIN_DEVICE_RBOILER   28       // ++ PWR_ON4 Включение ТЭНа бойлера
    #define PIN_DEVICE_R4WAY      11       // ++ PWR_ON5 4-ходовой клапан
 //   #define PIN_DEVICE_RFAN1   46       // - Реле включения вентилятора испарителя №1
 //   #define PIN_DEVICE_RFAN2   46       // - Реле включения вентилятора испарителя №2
 //   #define PIN_DEVICE_REVI    12       // - Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
    #define PIN_DEVICE_R3WAY     7        // ++ PWR_ON6 Трех ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
    #define PIN_DEVICE_RHEAT     30       // ++ PWR_ON7 Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.
    #define PIN_DEVICE_RPUMPB    29       // ++ PWR_ON8 Реле насоса циркуляции бойлера (ГВС)
    // НОГИ Устройства не силовые - выход сухой контакт (максимум до 4 штук)
 //   #define PIN_OMRON_START    2        // ++ DOUT1 Выход для управления пуском инвертора
    #define PIN_OMRON_RESET      3        // ++ DOUT2 Выход для сброса инвертора
//    #define PIN_5              5        // + DOUT3 Не используется
//    #define PIN_6              6        // + DOUT4 Не используется
	//#define RELAY_WAIT_SWITCH	11		  // Заморозить выполнение задач на это время после переключения реле, ms
 

    // Имена индексов ВАЖЕН ПОРЯДОК!
    #define RCOMP              0          // Реле включения компрессора (через пускатель)
    #define RPUMPI             1          // Реле включения насоса входного контура  (геоконтур)
    #define RPUMPO             2          // Реле включения насоса выхордного контура  (отопление и ГВС)
    #define RBOILER            3          // Включение ТЭНа бойлера
    #define R4WAY               4          // 4-ходовой клапан (охлаждение)
 //   #define RFAN1            5          // Реле включения вентилятора испарителя №1
 //   #define RFAN2            6          // Реле включения вентилятора испарителя №2
 //   #define REVI             5          // Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
    #define R3WAY              5          // Трех ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
    #define RHEAT              6          // Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.
    #define RPUMPB             7          // Реле насоса циркуляции бойлера (ГВС)
 //   #define RSTART             8          // Выход для управления пуском инвертор
    #define RRESET             8          // Выход для сброса инвертора

    
   // Массив ног соглано индексов
   const uint8_t pinsRelay[RNUMBER] = { PIN_DEVICE_RCOMP,       // ++ PWR_ON1 Реле включения компрессора (через пускатель)
                                        PIN_DEVICE_RPUMPI,      // ++ PWR_ON2 Реле включения насоса входного контура  (геоконтур)
                                        PIN_DEVICE_RPUMPO,      // ++ PWR_ON3 Реле включения насоса выхордного контура  (отопление и ГВС)
                                        PIN_DEVICE_RBOILER,     // ++ PWR_ON4 Включение ТЭНа бойлера
                                        PIN_DEVICE_R4WAY,        // ++ PWR_ON5 4-ходовой клапан
     //                                 PIN_DEVICE_RFAN1,       // - Реле включения вентилятора испарителя №1
     //                                 PIN_DEVICE_RFAN2,       // - Реле включения вентилятора испарителя №2
     //                                 PIN_DEVICE_REVI,        // ++ PWR_ON7 Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
                                        PIN_DEVICE_R3WAY,       // ++ PWR_ON6 Трех ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
                                        PIN_DEVICE_RHEAT,       // - Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.
                                        PIN_DEVICE_RPUMPB,      // ++ PWR_ON8 Реле насоса циркуляции бойлера (ГВС)
     //                                 PIN_OMRON_START,        // ++ DOUT1 Выход для управления пуском инвертора
                                        PIN_OMRON_RESET        // ++ DOUT2 Выход для сброса инвертора
                                       };
// Описание реле
  const char *noteRelay[RNUMBER] =  {"Реле включения компрессора (через инвертор)",
                                     "Реле включения насоса входного контура  (геоконтур)",
                                     "Реле включения насоса выходного контура (отопление и ГВС)",
                                     "Реле включение ТЭНа бойлера (ГВС)",
                                     "4-ходовой клапан (для режима охлаждения надо включить)",
 //                                    "Реле включения вентилятора испарителя №1",
 //                                    "Реле включения вентилятора испарителя №2",
 //                                    "Соленойд для EVI (испаритель ниже +3гр и конденсатор выше +40гр) ",
                                     "Трех ходовой кран, переключение ТН между отоплением и ГВС ",
                                     "Реле включение ТЭНа системы отопления (электрокотел)",
                                     "Реле насоса циркуляции бойлера (ГВС)",
 //                                    "Выход для управления пуском инвертора",
                                     "Выход для сброса инвертора"
                                    };
   //  Имя реле
  const char *nameRelay[RNUMBER] = { "RCOMP",          // Реле включения компрессора (через пускатель)
                                     "RPUMPI",         // Реле включения насоса входного контура  (геоконтур)
                                     "RPUMPO",         // Реле включения насоса выхордного контура  (отопление и ГВС)
                                     "RBOILER",        // Реле включение ТЭНа бойлера (ГВС)
                                     "R4WAY",           // 4-ходовой клапан инвертирован
 //                                    "RFAN1",          // Реле включения вентилятора испарителя №1
 //                                    "RFAN2",          // Реле включения вентилятора испарителя №2
 //                                    "REVI",           // Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
                                     "R3WAY",          // Трех ходовой кран, переключение ТН между отоплением и ГВС
                                     "RHEAT",          // Реле включение ТЭНа системы отопления (электрокотел)
                                     "RPUMPB",         // Реле насоса циркуляции бойлера (ГВС)
 //                                    "RSTART",         // Выход для управления пуском инвертора
                                     "RRESET"          // Выход для сброса инвертора
                                     } ; 
     
    // Конфигурация системы отопления --------------------------------------------------------------------------------
    // от куда брать температуру обратки и подачи системы отопления смотртеть кондесатор.
    // Могут быть задействованы разные датчики!
    // Конденсатор запитан  в противотоке!!
     #define FEED      sTemp[TCONOUTG].get_Temp()               // Подача системы СО- выход по гликолю кондесатора
     #define RET       sTemp[TCONING].get_Temp()                // Обратка системы СО- вход по гликолю кондесатора

     // Определение насосов конденсатора и испарителя по именам
     #define PUMP_OUT      RPUMPO                               // Насос выходного контура (отопление)
     #define PUMP_IN       RPUMPI                               // Насос входного  контура (гео или воздушник)

	// --------------------------------------------------------------------------------
	// ДАТЧИКИ и УСТРОЙСТВА - максимально поддерживаемые
	// --------------------------------------------------------------------------------
	#define TNUMBER     14      // Максимальное число температурных датчиков (то что поддерживается)
	#define SENSOR_IP           // Использование удаленных устройств( датчиков температуры смотрим IPNUMBER )
	#define IPNUMBER    1       // Максимальное число удаленных датчиков, запрет использования  SENSOR_IP
    #define RADIO_SENSORS_MAX 0 // Число радио датчиков
	#define ANUMBER     2       // Максимальное число аналоговых датчиков (то что поддерживается)
     // ДАТЧИКИ ТЕМПЕРАТУРЫ до 14 шт. СОТЫЕ ГРАДУСА ------------------------------------------------------------------------
    // наличие датчиков  датчиков от конфигурации минимальные максимальные и тестовые температуры
      // Температура хранится в сотых градуса
      #define TOUT        0  // 28FFBD5800160137 9 Температура улицы
      #define TIN         1  // 28FFBA5301150433 4 Температура в доме
      #define TEVAIN      2  // 28FFD35088160363 11 Температура на входе испарителя (по фреону)
      #define TEVAOUT     3  // 28FFEA4CB516052D 3 Температура на выходе испарителя (по фреону)
      #define TCONIN      4  // 28FFCF4488160308 14 Температура на входе конденсатора (по фреону)установлен 02.06.19
      #define TCONOUT     5  // 28FF2746881603EB 12 Температура на выходе конденсатора (по фреону) установлен 02.06.19
      #define TBOILER     6  // 289385A504000059 1 Температура в бойлере ГВС
      #define TACCUM      7  // 28FF4DE29216051D 7 Температура на выходе теплоаккмулятора
      #define TCOMPIN     8  // 28FF06058B160352 5 Температура на входе компрессора
      #define TCOMP       9  // 28FF2D4D881603C2 8 Температура нагнетания компрессора
      #define TEVAING     10 // 28FFB7419116049D 13 Температура на входе испарителя (по гликолю)
      #define TEVAOUTG    11 // 28FFDED0B5160398 6 Температура на выходе испарителя (по гликолю)
      #define TCONING     12 // 28FF53EBB31603B2 10 Температура на входе конденсатора (по гликолю)
      #define TCONOUTG    13 // 28FF7221911604FD 2 Температура на выходе конденсатора (по гликолю)
		// Имена датчиков
		const char *nameTemp[] = {"TOUT",             // Температура улицы
		                          "TIN",              // Температура в доме
		                          "TEVAIN",           // Температура на входе испарителя по фреону
		                          "TEVAOUT",          // Температура на выходе испарителя по фреону
		                          "TCONIN",           // Температура на входе конденсатора по фреону
		                          "TCONOUT",          // Температура на выходе конденсатора по фреону
		                          "TBOILER",          // Температура в бойлере ГВС
		                          "TACCUM",           // Температура на выходе теплоаккмулятора
		                          "TCOMPIN",          // Температура на входе компрессора
		                          "TCOMP",            // Температура нагнетания компрессора
		                          "TEVAING",          // Температура на входе испарителя по гликолю
		                          "TEVAOUTG",         // Температура на выходе испарителя по гликолю
		                          "TCONING",          // Температура на входе конденсатора по гликолю
		                          "TCONOUTG"          // Температура на выходе конденсатора по гликолю
		                           };           
		// Описание датчиков
		const char *noteTemp[] = {"Т° улицы",
		                          "Т° в доме",
		                          "Т° на входе испарителя по фреону",
		                          "Т° на выходе испарителя по фреону",
		                          "Т° на входе конденсатора по фреону",
		                          "Т° на выходе конденсатора по фреону",
		                          "Т° в бойлере ГВС",
		                          "Т° на выходе теплоаккумулятора",
		                          "Т° на входе компрессора (всас)",
		                          "Т° нагнетания", //  "Т° на выходе компрессора (нагнетание)"
		                          "Т° на входе испарителя по гликолю",
		                          "Т° на выходе испарителя по гликолю",
		                          "Т° на входе конденсатора по гликолю",
		                          "Т° на выходе конденсатора по гликолю"
		                          };
       // Наличие датчика в конфигурации
       const boolean SENSORTEMP[TNUMBER]={true,true,true,true,true,true,true,true,true/*3way*/,true,true,true,true,true};
       // минимальные значения температур
       const int16_t MINTEMP[TNUMBER]={-3500,-3000,-1500,-1000,-2000,-2000,0,-500,-1510,100,-1000,-1000,-1000,-1000};
       // Макимальные значения температур ВНИМАНИЕ! для TBOILER температура берется не здесь, она равна SALLMONELA_TEMP+300
       const int16_t MAXTEMP[TNUMBER]={4000,3500,2520,4000,8500,6520,5510,4200,4010,8700,2500,2500,5000,5500};
       // Значения датчиков при тестировании  опция TEST В СОТЫХ ГРАДУСА
       const int16_t TESTTEMP[TNUMBER]={1000,2000,300,400,1000,3000,765,123,-500,500,0,0,2000,2000};
       // Ошибки датчиков (систематические) нужны для калибровки ОШИБКИ ДОБАВЛЯЮТСЯ!!! к значениям В СОТЫХ ГРАДУСА
       const int16_t ERRTEMP[TNUMBER]=  {     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0 };

      // АНАЛОГОВЫЕ ДАТЧИКИ максимум 2 шт -------------------------------------------------------------------
      // наличие датчиков в конфигурации минимальные максимальные и тестовые значения
       // Справочно нумерация датчиков
       // Давление харится в сотых бара
      	#define PEVA			0                // Датчик давления испарителя.
      	#define PCON			1                // Датчик давления конденсатора.
       const char *nameAnalog[] =       {
                                        "PEVA",
                                        "PCON"
                                        };
      // Описание датчиков
      const char *noteAnalog[] = {"Давление испарителя (bar)", // Датчик давления испарителя.
                                 "Давление конденсатора (bar)"};  // Датчик давления конденсатора.

     // Коэффициент преобразования отсчеты АЦП-давление
      const uint16_t TRANsADC[ANUMBER]={482,300};
      // напряжение (отсчеты АЦП) соответсвующее cZero
      const uint16_t ANALOG_ZERO[ANUMBER]={285,150};

      const boolean ANALOG_SENSORS[ANUMBER]={true,false};    
      const int16_t ANALOG_MIN[ANUMBER]={350,100};        // минимальные значения давления
      const uint16_t ANALOG_MAX[ANUMBER]={1500,3000};     // Макимальные значения давления
      const uint16_t ANALOG_TEST[ANUMBER]={600,1200};      // Значения датчиков при тестировании  опция TEST
      // ------------------- ADC SENSOR ----------------------------------
      #define ADC_PRESCAL		10             // [20]  = (42 / ADCClockMhz - 1)
      #define ADC_SKIP_EXTREMUM 400            // [400] Отбрасывать максимумы/минимумы больше заданной дельты
      #define P_NUMSAMLES       1              // [1]   Число значений для усреднения показаний давления
      #define ADC_FREQ        100            // [20]  Частота опроса аналоговых датчиков
      #define FILTER_SIZE       128            // [40]  Длина фильтра для датчика давления
      #define FILTER_SIZE_OTHER 8              // [8]   Длина фильтра для остальных датчиков
      // Графики в памяти
    	Charts_Mod_setup ChartsModSetup[] = {
    		{ STATS_OBJ_Temp, TOUT },
    		{ STATS_OBJ_Temp, TIN },
    		{ STATS_OBJ_Temp, TBOILER },
    		{ STATS_OBJ_Temp, TCOMP },
    		{ STATS_OBJ_Temp, TCOMPIN },  // вход компрессора
    		{ STATS_OBJ_Temp, TACCUM },   // аккумулятор
    		{ STATS_OBJ_Temp, TEVAING },
    		{ STATS_OBJ_Temp, TEVAOUTG },
    		{ STATS_OBJ_Temp, TCONING },
    		{ STATS_OBJ_Temp, TCONOUTG },
   // 		{ STATS_OBJ_Temp, TEVAIN },   // не нужен
    		{ STATS_OBJ_Temp, TEVAOUT },
   // 		{ STATS_OBJ_Temp, TCONIN },   // не нужен
    		{ STATS_OBJ_Temp, TCONOUT },
    //		{ STATS_OBJ_Temp, TSUN },
    //		{ STATS_OBJ_Temp, TSUNOUTG },
    //		{ STATS_OBJ_Flow, FLOWEVA },
    		{ STATS_OBJ_Flow, FLOWCON },
    //		{ STATS_OBJ_Press, PGEO },
    //		{ STATS_OBJ_Press, POUT },
    //		{ STATS_OBJ_PressTemp, PCON },
 	//   		{ STATS_OBJ_PressTemp, PEVA }
 	   		{ STATS_OBJ_Press, PEVA }	// Давление	
    	};
    	const Charts_Const_setup ChartsConstSetup[] = {
    		{ STATS_OBJ_EEV, "ЭРВ" },                  // Отключать нельзя используется на странице ЭРВ
    		{ STATS_OBJ_Overheat, "Перегрев" },        // Отключать нельзя используется на странице ЭРВ
    		{ STATS_OBJ_Overheat2, "Цель перегрева" }, // Отключать нельзя используется на странице ЭРВ это цель перегрева
    		{ STATS_OBJ_Compressor, "Частота, Гц" },
    		{ STATS_OBJ_Power_FC, "Мощность компрессора" },
    		{ STATS_OBJ_Power, "Потребляемая мощность" },
    		{ STATS_OBJ_Voltage, "Напряжение сети" },
     		{ STATS_OBJ_COP_Full, "Full COP" }
    	};
    	const Charts_Const_setup ChartsOnFlySetup[] = {
    		{ STATS_OBJ_Overcool, "Переохлаждение" }, // T[PCON] - TCONOUT
    		{ STATS_OBJ_TCOMP_TCON, "Нагнетание - Конденсация" }, // TCOMP - TCON Отключать нельзя используется на странице ЭРВ
    		{ STATS_OBJ_Delta_GEO, "Δ t° геоконтура" }, // TEVAING - TEVAOUTG
    		{ STATS_OBJ_Delta_OUT, "Δ t° выхода" }, // TCONOUTG - TCONING
  //  		{ STATS_OBJ_Power_GEO, "Мощность геоконтура" }, // (TEVAOUTG - TEVAING) * FLOWEVA / kfCapacity
    		{ STATS_OBJ_Power_OUT, "Выходная мощность" } // (TCONOUTG - TCONING) * FLOWCON / kfCapacity
    	};

       // История (графики) пишется на карту
      const History_setup HistorySetup[] = {
      	{ STATS_OBJ_Temp, TOUT, nameTemp[TOUT] },
      	{ STATS_OBJ_Temp, TIN, nameTemp[TIN] },
      	{ STATS_OBJ_Temp, TBOILER, nameTemp[TBOILER] },
      	{ STATS_OBJ_Temp, TCOMP, nameTemp[TCOMP] },
      	{ STATS_OBJ_Temp, TEVAING, nameTemp[TEVAING] },
      	{ STATS_OBJ_Temp, TEVAOUTG, nameTemp[TEVAOUTG] },
      	{ STATS_OBJ_Temp, TCONING, nameTemp[TCONING] },
      	{ STATS_OBJ_Temp, TCONOUTG, nameTemp[TCONOUTG] },
      	{ STATS_OBJ_Temp, TEVAOUT, nameTemp[TEVAOUT] },
//    	{ STATS_OBJ_Temp, TCONOUT, noteTemp[TCONOUT] },
//		{ STATS_OBJ_PressTemp, PEVA, "Температура кипения" },
//		{ STATS_OBJ_PressTemp, PCON, "Температура конденсации" },
//		{ STATS_OBJ_Flow, FLOWEVA, noteFrequency[FLOWEVA] },
		{ STATS_OBJ_Flow, FLOWCON, nameFrequency[FLOWCON] },
		{ STATS_OBJ_EEV, STATS_EEV_Steps, "EEV" },
		{ STATS_OBJ_EEV, STATS_EEV_OverHeat, "OverHeat" },
//		{ STATS_OBJ_EEV, STATS_EEV_OverCool, "Переохлаждение" },
		{ STATS_OBJ_Compressor, 0, "Freq" },
		{ STATS_OBJ_Power, 0, "power220" },
		{ STATS_OBJ_Power_OUT, 0, "powerCO" },
		{ STATS_OBJ_COP_Full, 0, "fullCOP" }
      };
      // ------------------- EEV -----------------------------------
      // ЭРВ ТОЛЬКО ОДНА ШТУКА ВСЕГДА (не массив) ------------------
       #define EEV_DEF                                // Наличие ЭРВ в конфигурации
		#define FREON                  R410A 		  // Тип фреона

  //    #define PID_FORMULA2			    	      // использовать адаптированный алгоритм ПИД Arduino-PID-Library
       #define DEF_FC_PID_P_ON_M        false         // Режим ПИДа отопления, бойлера - true пропорционально измерению, false - пропорционально ошибке   актуально для PID_FORMULA2
       #ifdef EEV_DEF                                 // ЭРВ настройки
	    //  Константы (из программы не меняются)
		#define EEV_STEPS              490            // Число шагов ЭРВ 480
		#define EEV_QUEUE              10             // Длина очереди команд шагового двигателя ЭРВ
	    #define EEV_CLOSE_STEP         2              // Позиция ЭРВ - Закрыто
		#define EEV_PHASE              PHASE_8s       // ЗАДАННАЯ (можно менять) последовательность (шагов) при движении ЭРВ
	    //#define EEV_INVERT                          // Признак инвертирования движения ЭРВ  (меняем если крутит в обратную сторону)
  	    #define EEV_MIN_CONTROL                       // Контроль нижней границы ЭРВ - останов по ошибке.
	    #define EEV_MAX_CONTROL                       // Контроль верхней границы ЭРВ, включать только если ЭРВ правильно подобран (верхняя граница не достижима в процессе работы)
	     
		// Значения по умолчанию (можно менять из морды)
		#define DEFAULT_RULE_EEV       TEVAOUT_PEVA   // Формула по умолчанию - TEVAOUT_PEVA
		#define DEFAULT_EEV_TIME	   50			  // Постоянная интегрирования времени в секундах ЭРВ СЕКУНДЫ
		#define DEFAULT_OVERHEAT       310			  // Перегрев по умолчанию (сотые градуса)
		#define DEFAULT_EEV_Kp	       2500			  // ПИД Коэф пропорц.  В ТЫСЯЧНЫХ
		#define DEFAULT_EEV_Ki	       800			  // ПИД Коэф интегр.   В ТЫСЯЧНЫХ
		#define DEFAULT_EEV_Kd	       900			  // ПИД Коэф дифф.     В ТЫСЯЧНЫХ
	    #define DEFAULT_ERR_KP         0              // Ошибка (в сотых градуса) при которой происходит уменьшение пропорциональной составляющей ПИД ЭРВ
	    #define DEFAULT_SPEED_EEV      80             // Скорость шагового двигателя ЭРВ (импульсы в сек.)
	    #define DEFAULT_PRE_START_POS  100            // ПУСКОВАЯ позиция ЭРВ (ТО что при старте компрессора ПРИ РАСКРУТКЕ)
	    #define DEFAULT_START_POS      90             // СТАРТОВАЯ позиция ЭРВ после раскрутки компрессора т.е. ПОЗИЦИЯ С КОТОРОЙ НАЧИНАЕТСЯ РАБОТА проходит DelayStartPos сек
	    #define DEFAULT_HOLD_MOTOR     false          // Режим "удержания" шагового двигателя ЭРВ
    	// Корректировки для фреона R410a
	  	#define DEF_OHCor_TDIS_TCON			2400		// Разница температура нагнетания - конденсации при 30С, 0 конденсации и перегреве OHCor_OverHeatStart (в сотых)
		#define DEF_OHCor_TDIS_TCON_Thr 	20		    // Порог, после превышения TDIS_TCON + TDIS_TCON_Thr начинаем менять перегрев (в десятых)
  		#define DEF_OHCor_CONDENSING_30_MUL 57			// Корректировка разницы Нагнетание-Конденсация на кажлые 10 градусов конденсации от 30 (в десятых), зависит от фреона
		#define DEF_OHCor_EVAPORATING_0_MUL 86			// Корректировка разницы Нагнетание-Конденсация на кажлые -10 градусов кипения от 0 (в десятых), зависит от фреона
		#define DEF_OHCor_Delay 			300         // Задержка после старта компрессора, сек
  		#define DEF_OHCor_Period 			10		    // Период в циклах ЭРВ, сколько пропустить
		#define DEF_OHCor_K 				100      	// Коэффициент (/0.001): перегрев += дельта * K
		#define DEF_OHCor_OverHeatMin 		150    		// Минимальный перегрев (сотые градуса)
		#define DEF_OHCor_OverHeatMax 		400    		// Максимальный перегрев (сотые градуса)
		#define DEF_OHCor_OverHeatStart 	300		  	// Начальный перегрев (сотые градуса)
	    // ЭРВ Времена и задержки
	    #define DEFAULT_DELAY_ON_PID    120            // Задержка включения EEV после включения компрессора (сек).  Точнее после выхода на рабочую позицию Общее время =delayOnPid+DelayStartPos
	    #define DEFAULT_DELAY_ON        5             // Задержка между открытием (для старта) ЭРВ и включением компрессора, для выравнивания давлений (сек). Если ЭРВ закрывлось при остановке
	    #define DEFAULT_DELAY_START_POS 30            // Время после старта компрессора когда EEV выходит на стартовую позицию - облегчение пуска вначале ЭРВ
	    #define DEFAULT_DELAY_OFF       10            // Задержка закрытия EEV после выключения насосов (сек). Время от команды стоп компрессора до закрытия ЭРВ = delayOffPump+delayOff
	  #endif

      // Частотный преобразователь ТОЛЬКО ОДНА ШТУКА ВСЕГДА (не массив) --------------------------------------------------------
      const boolean DEVICEFC=true;                // Наличие Частотного преобразователя в конфигурации
 //     #define FC_ANALOG_CONTROL                      // Использование аналогового управления частотником, Для использования 485 закоментировать эту строку
      #ifdef  FC_ANALOG_CONTROL
        #define FC_USE_RCOMP                   // Если определен аналог всегда использовать отдельный выход на команду ХОД
      #endif  
    
      // Константы частотного преобразователя для конкртеной  реализации
      #define FC_USE_RCOMP                        // Использовать для пуска/остановки инвертора отдельный выход RCOMP (команда по модбасу не посылается)
      // КОНСТАНТЫ
      #define FC_DT_CON_PRESS     50               // Защита по давлению компрессора - сколько сотых бара не доходит до максимальной (PCON) и при этом происходит уменьшение частоты
      #define FC_MAX_POWER        (1.8*1000)       // Максимальная мощность инвертора (см компрессор) в 0.1 кВт
      #define FC_MAX_POWER_BOILER (1.3*1000)       // Максимальная мощность инвертора в режиме ГВС (см компрессор) в 0.1 кВт
      #define FC_MAX_CURRENT      (10.0*100)       // Максимальный ток инвертора (см компрессор) в 0.01 А
      #define FC_MAX_CURRENT_BOILER (11.0*100)     // Максимальный ток инвертора для ГВС в 0.01 А
      #define FC_BASE_FREQ        (120*100)        // Основная частота инвертора (см компрессор) в 0.01 Гц
      #define FC_ACCEL_TIME       (60*100)         // Время разгона (см компрессор) в 0.01 сек
      #define FC_DEACCEL_TIME     (60*100)         // Время торможения (см компрессор) в 0.01 сек
	  #define FC_START_PID_DELAY  (30*100)         // Задержка ПИД после старта компрессора

      // Значения по умолчанию (начало DEF_) не Константы
      #define DEF_FC_DT_COMP_TEMP     (5*100)        // Защита по температуре компрессора - сколько градусов не доходит до максимальной (TCOMP) и при этом происходит уменьшение частоты
      #define DEF_FC_UPTIME           (10)         // Время обновления алгоритма пид регулятора (мсек) Основной цикл управления
      #define DEF_FC_PID_FREQ_STEP    (2*100)        // Максимальный шаг (на увеличение) изменения частоты при ПИД регулировании в 0.01 Гц Необходимо что бы ЭРВ успевал
      #define DEF_FC_PID_STOP            90          // Проценты от уровня защит (мощность, ток, давление, темпеартура) при которой происходит блокировка роста частоты пидом (плавный подход к границе)
      #define DEF_FC_START_FREQ        (55*100)       // Стартовая частота частота инвертора отопление/охлаждение (см компрессор) в 0.01 Гц
      #define DEF_FC_START_FREQ_BOILER (45*100)      // Стартовая частота частота инвертора ГВС (см компрессор) в 0.01 Гц ГВС
      #define DEF_FC_MIN_FREQ         (40*100)       // Минимальная  частота инвертора при нагреве (см компрессор) в 0.01 Гц
      #define DEF_FC_MIN_FREQ_COOL    (60*100)       // Минимальная  частота инвертора при охлаждении в 0.01 Гц
      #define DEF_FC_MIN_FREQ_BOILER  (40*100)       // Минимальная  частота инвертора при нагреве ГВС в 0.01 Гц
      #define DEF_FC_MIN_FREQ_USER    (35*100)       // Минимальная  частота инвертора РУЧНОЙ РЕЖИМ (см компрессор) в 0.01 Гц
      #define DEF_FC_MAX_FREQ         (130*100)      // Максимальная частота инвертора при нагреве (см компрессор) в 0.01 Гц
      #define DEF_FC_MAX_FREQ_COOL    (100*100)      // Максимальная частота инвертора в режиме охлаждения  в 0.01 Гц
      #define DEF_FC_MAX_FREQ_BOILER  (50*100)       // Максимальная частота инвертора в режиме ГВС в 0.01 Гц поглощение бойлера обычно меньше чем СО
      #define DEF_FC_MAX_FREQ_USER    (120*100)      // Максимальная частота инвертора РУЧНОЙ РЕЖИМ (см компрессор) в 0.01 Гц
      #define DEF_FC_STEP_FREQ        (2*100)        // Шаг уменьшения частоты инвертора при достижении максимальной температуры, мощности и тока (см компрессор) в 0.01 Гц
      #define DEF_FC_STEP_FREQ_BOILER (5*100)        // Шаг уменьшения частоты инвертора при достижении максимальной температуры, мощности и тока ГВС в 0.01 Гц
      #define DEF_FC_DT_TEMP          (1*100)        // Привышение температуры от уставок (подача) при которой срабатыват защита (уменьшается частота) в сотых градуса
      #define DEF_FC_DT_TEMP_BOILER   (2*100)        // Привышение температуры от уставок (подача) при которой срабатыват защита ГВС в сотых градуса
   
  #endif  // конец Главного конфига 5


// -----------------------------------------------------------------------------------------------------------------------------------
// =============================================== C O N F I G   6 ===================================================================
// -----------------------------------------------------------------------------------------------------------------------------------
#ifdef CONFIG_6    // Имя и описание конфигурации и ОСОБЕННОСТИ конфигурации ---------------------------------------------------------

    #define CONFIG_NAME   "NTC"
    #define CONFIG_NOTE   "Частотник PWM, 1 фаза, 4 реле, ЭРВ, NTC"
    #define HP_SCHEME     3			// Номер схемы который выводится на морде, подмена файлов plan[HPscheme].png -> plan1.png
    #define UART_SPEED    250000	// Скорость отладочного порта
	#define KEY_ON_OFF				// KEY1 Наличие кнопки включения и переключения в safeNetwork (нажата при сбросе)
    #define SPI_FLASH				// Наличие чипа флеш памяти на шине SPI
	#define NO_SD_CARD				// SD карты нет
    #define LOAD_VERIFICATION     	// Признак чтения настроек c проверкой версии, длины, CRC16. Закоментируйте эту строку для ПОПЫТКИ загрузить старый формат, Запись всегда идет в новом
    #define CHART_ONLY_COMP_ON      // Накопление точек для графиков ТОЛЬКО если компрессор работает, иначе всегда (и в паузах тоже) когда ТН включен
//   #define CLEAR_CHART_HP_ON      // Очистка графиков при страте ТН
// 	#define NEXTION                 // Разрешить использование дисплея. ЗАКОМЕНТИРУЙТЕ эту строку, что бы не использовать дисплей
    #ifdef 	NEXTION
//   	#define NEXTION_GENERATOR   // Показ на nextion кнопки "Работа от генератора" (ограничение мощности потребления)
    #endif 
    #define USE_ELECTROMETER_SDM    // Наличие счетчика SDM
//    #define USE_SDM630        	// Наличие счетчика SDM630 - 3 фазы
	#define USE_PZEM004T			// Наличие электросчетчика PZEM-004T v3 Modbus/UART
//    #define EXTERNAL_AREF     	  	// Использование внешней опоры для АЦП
    #ifdef EXTERNAL_AREF        	// Какая опора для АЦП используется
      #define SAM3X_ADC_REF  3.00   // Используется внешняя опора ADR4530ARZ
    #else
      #define SAM3X_ADC_REF  3.30   // Штатное подключение используется питание DUE
    #endif
	#define USE_RC_CLOCK_SOURCE		// Использовать RC цепочку для часов
//    #define USE_UPS					// Используется ИБП на контроллер, проверка через вход SPOWER
	#define STATS_USE_BUFFER_FOR_SAVING // Сохранять статистику только когда буфер (512 байт) заполнен, иначе каждый день
	#define MIN_RAM_CHARTS

	#define ONEWIRE_DS2482			// + Использование мастера i2c Onewire DS2482 (адрес AD1,0 = 0,0)
	#define ONEWIRE_DS2482_SECOND	// второй мастер i2 Onewire DS2482 (адрес AD1,0 = 0,1)
//	#define ONEWIRE_DS2482_THIRD	// третий мастер i2 Onewire DS2482 (адрес AD1,0 = 1,0)
//	#define ONEWIRE_DS2482_FOURTH	// четвертый мастер i2 Onewire DS2482 (адрес AD1,0 = 1,1)
//	#define ONEWIRE_DS2482_2WAY  	// Используются 2-х проводные шины OneWire (паразитное питание)
	#ifdef ONEWIRE_DS2482_2WAY
      const uint8_t ONEWIRE_2WAY = 0b1010; // На каких шинах (4|3|2|1) двух-проводные датчики, битовая маска
	#else
      const uint8_t ONEWIRE_2WAY = 0b0000;
	#endif
//	#define PIN_ONE_WIRE_BUS   23       // нога с интерфейсом программный OneWire ВСЕ температурные датчики

//	#define USE_SUN_COLLECTOR			// Используется солнечный/воздушный коллектор (работает при включенном ТН постоянно, если позволяет температура)
	#define SUN_TDELTA			300		// Дельта температур для включения, сотые градуса, по умолчанию
	#define SUNG_TDELTA			200		// Дельта температур жидкости для выключения, сотые градуса, по умолчанию
	#define SUN_MIN_WORKTIME	120000	// минимальное время работы, после которого будут проверятся границы, мсек.
	#define SUN_MIN_PAUSE		900000	// минимальное время паузы после останова СК, мсек.

//	#define RADIO_SENSORS			// Радиодатчики через ZONT МЛ‑489.
    // Подключение через плату UART - K-line или через 4 платы UART-RS485 отдельно на RX и TX, на стороне МЛ-489 : питание 5V, через диод K-line >--TX--|>|--RX
    // Новый датчик ждем в течении 2-х минут после старта НК (нажать кнопку датчика пока не загорится его светодиод)
	#define RADIO_SENSORS_PORT		2				// Номер Serial
	#define RADIO_SENSORS_PSPEED	115200			// Скорость порта
	#define RADIO_SENSORS_PCONFIG	SERIAL_8N1		// Конфигурация порта

	//#define USE_SERIAL4							// Использовать порт Serial4 на D52(RXD2) и A11/D62(TXD2)

	#define FORMAT_DATE_STR_CUSTOM
    const char *FORMAT_DATE_STR	 = { "%02d.%02d.%04d" };
//	#define HTTP_TIME_REQUEST	// Запрос времени по HTTP протоколу с собственного сервера (текстовый файл формата: "<время UTC>;").
    							// У меня берется с электросчетчика Меркурий 231 АТ через подключенный к нему esp8266 (http://vad-7.blogspot.com/2017/03/mercury231.html)
	#ifdef HTTP_TIME_REQUEST
    const char HTTP_TIME_REQ[]	= "/curr_time.csv";
	#endif
	#define INDEX_FILE			"index.html"       // стартовый файл по умолчанию для веба
	//#define WEB_STATUS_SHOW_VERSION		// Показывать версию в строке статуса (запрос get_status)
	//#define WEB_STATUS_SHOW_OVERHEAT		// Показывать перегрев в строке статуса (запрос get_status)

	#define DEBUG                   // В последовательный порт шлет сообщения в первую очередь ошибки
//	#define DEBUG_NATIVE_USB		// Отладка через второй USB порт (Native)
//	#define DEBUG_MODWORK           // Вывод в консоль состояние HP при работе
//	#define DEBUG_PID				// Отладка ПИДа
//	#define I2C_EEPROM_64KB	        // Использование памяти I2C для записи журнала при коментарии используется оперативка
	#define I2C_FRAM_MEMORY  0		// 1 - FRAM память
//	#define DONT_LOG_SUCCESS_PING	// Не логировать в журнал успешные пинги
	#ifdef  I2C_EEPROM_64KB                    // В зависимости от типа чипа
		#define I2C_ADR_EEPROM    0x50         // Адрес чипа на шине I2C
		#define I2C_SIZE_EEPROM   512    	   // Объем чипа в килобитах
  		#define I2C_MEMORY_TOTAL  1024   	   // Итоговый размер I2C памяти в килобитах
		#define I2C_PAGE_EEPROM   64           // Размер страницы для чтения, байты
	#else // все остальное
		#define I2C_ADR_EEPROM    0x50         // Адрес чипа на шине I2C
		#define I2C_SIZE_EEPROM   64	       // Объем чипа в килобитах
		#define I2C_MEMORY_TOTAL  I2C_SIZE_EEPROM // Итоговый размер I2C памяти в килобитах
		#define I2C_PAGE_EEPROM   32           // Размер страницы для чтения, байты
	#endif
//	#define REBOOT_ON_I2C_ERRORS				// Soft RESET при постоянной ошибке I2C

	#define MQTT                             // признак использования MQTT, при неиспользовании необходимо закоментировать

      // FREE RTOS  Размеры стеков задач -----------------------------------------------
    #define STACK_vUpdateCommand  180                              // Стек задачи выполнение команд управления (разбор очереди комманд)
    #define STACK_vWebX           180                              // Стек задачи веб морды один поток (потоков может быть 1-4)

	#define SD_CLOCK				28	// частота SPI для SD карты в МГц
    // СЕТЕВЫЕ НАСТРОЙКИ --------------------------------------------------------------
	uint8_t SPI_RATE 			  = 2;	// делитель для SPI шины, 2=42MHz, 3=28MHz, 4=21MHz, 6=14MHz
	const boolean   defaultDHCP	=	false;
	const IPAddress defaultIP		(192, 168, 0, 199);
	const IPAddress defaultGateway	(192, 168, 0, 1);
	const IPAddress defaultSDNS		(8, 8, 8, 8);
	const IPAddress defaultSubnet   (255, 255, 255, 0);
     //  #define SUPERBOILER               // Использование предкондесатора для нагрева ГВС
     //  #define SUPERBOILER_FC (90*100)   // частота супербойлера для частотника
     //  #define SUPERBOILER_DT (10*100)   // разница температур компресссора и бойлера для включения насоса
    // --------------------------------------------------------------------------------
    // ЖЕЛЕЗО  - привязка к ногам контроллера  В зависимости от конкретной схемы и платы
    // Для каждой конфигурации теперь свои определения!!!
    // --------------------------------------------------------------------------------
    // Конфигурирование Modbus для инвертора и счетчика SDM
    #define MODBUS_PORT_NUM         Serial1     // Аппаратный порт куда прицеплен Modbus
    #define MODBUS_PORT_SPEED       9600        // Скорость порта куда прицеплен частотник и счетчик
    #define MODBUS_PORT_CONFIG      SERIAL_8N1  // Конфигурация порта куда прицеплен частотник и счетчик
    #define MODBUS_TIME_WAIT        1000        // Время ожидания захвата мютекса для modbus мсек
    #define MODBUS_TIME_TRANSMISION 0           // Пауза (msec) между запросом и ответом по модбас было 4
    //#define PIN_MODBUS_RSE          22          // Не используется из-за платы UART-RS485! Управление направлением передачи 485 для связи с инвертором по Modbus (1-передача 0-прием)

    // Защиты по входному напряжению. Используется счетчик SDM*
	#define SDM_MIN_VOLTAGE     120.0          // Минимальное напряжение работы ТН при падении - предупреждение
	#define SDM_MAX_VOLTAGE     265.0          // Максимальное напряжение работы ТН при падении - выключение ТН
	#define SDM_MAX_POWER       7500.0         // Максимальная мощность потребления (ватт) - выключение ТН

    // SPI шина управление отдельными устройствами до 3-х устройств (активный уровень низкий)
    #define PIN_SPI_CS_W5XXX	10			// ETH-CS   сигнал CS управление сетевым чипом w5500
    #define PIN_SPI_CS_SD		4			// SD-CS    сигнал CS управление SD картой
    #define PIN_SPI_CS_FLASH	52			// (67) FLASH-CS сигнал CS управление чипом флеш памяти (D52 пересекается с Serial4!)

    // Сервис
    #define PIN_ETH_RES         8         // ++ ETH-RES Сброс сетевого чипа w5500 активный low нормально high
    #define PIN_ETH_INT         3         // ++ ETH-INT Прерывание с w5500 пока не используется надо програмировать на вход
    #define PIN_LED1           13         // ++ LED1 Первый красный светодиод для контроля (питание и фатальная ошибка freeRTOS)
    #define PIN_LED_ERROR      PIN_LED1   // Для библиотеки FreeRTOS
    #define PIN_LED_OK         44         // ++ LED2 Второй зеленый светодиод Выход на светодиод мигает 0.5 герца - ОК  с частотой 2 герца ошибка
    #define PIN_KEY1           53         // ++ KEY1 Первая кнопка (ТН вкл/вкл) Нажатие при включении - режим safeNetwork (настрока сети по умолчанию 192.168.0.177  шлюз 192.168.0.1, не спрашивает пароль на вход в веб морду)
    #define PIN_BEEP           69         // ++  SOUND Выход на пищалку
     
    // EEV куда подключено общий СИНИЙ
    #define PIN_EEV1_D24       40  // 1 нога ЭРВ +А ОРАНЖЕВЫЙ - коричневый
    #define PIN_EEV2_D25       41  // 2 нога ЭРВ +B КРАСНЫЙ - желтый
    #define PIN_EEV3_D26       38  // 3 нога ЭРВ -A ЖЕЛТЫЙ - зеленый
    #define PIN_EEV4_D27       39  // 4 нога ЭРВ -B ЧЕРНЫЙ - белый
                                   // 5 нога ЭРВ Об.+12V СЕРЫЙ - экран
  
    //#define PIN_DEVICE_12V1  43  // 12в силовой выход с ULN2003 (3 выхода в параллель) (пока не поддерживается прошивкой)
    //#define PIN_DEVICE_12V2  42  // 12в силовой выход с ULN2003 одинарный  (пока не поддерживается прошивкой)
    //#define PIN_DEVICE_12V3  45  // 12в силовой выход с ULN2003 одинарный (пока не поддерживается прошивкой)
    // выходы 0-10в
   // #define PIN_DEVICE_FC        DAC0  // ++ DAC0  //Частотный преобразователь, выход 0-10в
   //#define PIN_DEVICE_FC2        DAC1  // ++ DAC1   //Частотный преобразователь2, выход 0-10в (пока не поддерживается прошивкой)
   //#define PIN_DEVICE_PWM1       2  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
   //#define PIN_DEVICE_PWM1       5  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
   //#define PIN_DEVICE_PWM1       6  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
   //#define PIN_DEVICE_PWM1       7  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
    // датчики
 
    // Контактные датчики ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
    #define INUMBER             3   // Максимальное число контактных датчиков цифровые входы (то что поддерживается)
    //  Ноги куда прицепленны контактные датчики
	#define PIN_SENSOR_1	    34
	#define PIN_SENSOR_2	    35
	#define PIN_SENSOR_3	    32
	//#define PIN_SENSOR_POWER    63  //  Датчик наличия высокого напряжения
    //#define PIN_SENSOR_SERRFC   38  //         // Сигнал ошибка инвертора
    //#define PIN_SENSOR_SFLOWCON 39             // Датчик потока по кондесатору
    //#define PIN_SENSOR_SFLOWEVA 40             // Датчик потока по испарителю
    //#define PIN_SENSOR_SEVA     41             // Датчик протока по испарителю
    // Имена индексов ВАЖЕН ПОРЯДОК!
	//#define SPOWER            0        // Датчик наличия питания (220/380V)
    //#define SERRFC            1        // Сигнал ошибка инвертора

      // Массив ног соглано индексов
     const uint8_t pinsInput[INUMBER] = {
    		 PIN_SENSOR_1,
			 PIN_SENSOR_2,
			 PIN_SENSOR_3
                                         };
      // Описание датчиков
      const char *noteInput[INUMBER] = {
                                         "Датчик 1",
    		  	  	  	  	  	  	  	 "Датчик 2",
    		  	  	  	  	  	  	  	 "Датчик 3"
                                       };
      // Имена датчиков
      const char *nameInput[INUMBER] = {
                                        "Sens1",
                                        "Sens2",
                                        "Sens3"
                                       };          
     
      const bool TESTINPUT[INUMBER]       =  {   0,      0,      0    };  // Значения датчиков при тестировании  опция TEST
      const bool ALARMINPUT[INUMBER]     =   {   0,      0,      0    };  // Значение датчика при аварии  ПРОВЕРИТЬ НА РЕАЛЬНОЕ СООТВЕТВИЕ (актуально только для pALARM )
      const TYPE_SENSOR SENSORTYPE[INUMBER] ={ pALARM, pALARM, pALARM };   // тип контактного датчика  pALARM, pSENSOR, pPULSE
    // ---------------------------------------------------------------------------------------------------------------------------------------
    // Частотные датчики ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
    #define FNUMBER				2       // Максимальное число частотных датчиков цифровые входы (то что поддерживается) код поддерживает 5 датчиков максимально!
    //  Ноги куда прицепленны контактные датчики - разъемы X7 и X8 перепаяны под 12V!
    #define PIN_SENSOR_FLOWEVA   36     // P1. Датчик потока по испарителю
    #define PIN_SENSOR_FLOWCON   37     // P2. Датчик потока по кондесатору
    // SIKA VVX25: +12V - коричневый (Xn.2), GND - голубой (Xn.3), выход - черный (Xn.1)
    // НЕ ПОДКЛЮЧЕН:
    //  #define PIN_SENSOR_FLOWPCON  68   // Датчик протока предконденсатора
     // Имена индексов ВАЖЕН ПОРЯДОК!
    #define FLOWEVA				0        // Датчик потока по испарителю
    #define FLOWCON				1        // Датчик потока по кондесатору
    //#define FLOWPCON			2        // Датчик протока по предконденсатору
      // Массив ног соглано индексов
    const uint8_t pinsFrequency[FNUMBER] = { PIN_SENSOR_FLOWEVA,      // Датчик потока по испарителю
                                             PIN_SENSOR_FLOWCON     // Датчик потока по кондесатору
 //                                         ,PIN_SENSOR_FLOWPCON     // Датчик протока по предконденсатору
                                    	   };
      // Описание датчиков
    const char *noteFrequency[FNUMBER] = { "Проток геоконтура (м³ч)",      // Датчик потока по испарителю
                                           "Проток отопления (м³ч)"        // Датчик потока по кондесатору
 //                                       ,"Датчик протока по предконденсатору (кубы/час)" //  Датчик протока по предконденсатору
                                       	};
      // Имена датчиков
    const char *nameFrequency[FNUMBER] = {  "FLOWEVA",        // Датчик потока по кондесатору
                                            "FLOWCON"         // Датчик потока по кондесатору
 //                                         ,"FLOWPCON"       // Датчик протока по предконденсатору
                                           };          
      // не забываем настраивать массивы под число датчиков
    const uint16_t TRANSFLOW[FNUMBER]= {10000,  10000};   // Коэффициент преобразования частота - поток, сотые
    const uint16_t TESTFLOW[FNUMBER] = { 2000,   1500};   // Значения датчиков при тестировании  опция TEST
    const uint8_t  MINFLOW[FNUMBER] =  {    4,      3};   // МИНИМАЛЬНЫЕ Значения датчиков, десятые m3
	#define FLOW_CONTROL								  // Контроль потоков через ПТО (актуален если установлены расходомеры)

   // Исполнительные устройства (реле и сухие контакты) ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
	#define RELAY_INVERT			// Реле выходов: включение высоким уровнем (High Level trigger)
    #define RNUMBER                    4 // Число исполнительных устройств (всех)
     // устройства DC 24V

     // устройства AC 220V
	#define PIN_DEVICE_RPUMPI          27 //[P27] Реле включения насоса входного контура  (геоконтур)
    #define PIN_DEVICE_RPUMPO          29 //[P29] Реле включения насоса выходного контура  (отопление и ГВС)
    #define PIN_DEVICE_RPUMPBH         31 //[P31] Реле насоса НАГРЕВА бойлера (ГВС) - не циркуляция
	#define PIN_DEVICE_RCOMP           33 //[P33] Реле включения компрессора.
//	#define PIN_DEVICE_RBOILER         33 //[P33] Включение ТЭНа бойлера
//    #define PIN_DEVICE_R4WAY           51 // 4-ходовой клапан
//    #define PIN_DEVICE_RPUMPFL         11 // реле насоса Теплого Пола
	#ifdef USE_SUN_COLLECTOR
    	#define PIN_DEVICE_RSUN        46 // Реле включения насоса солнечного коллектора
		#define PIN_DEVICE_RSUN_ON     53 // Реле включение шарового крана солнечного коллектора
		#define PIN_DEVICE_RSUN_OFF    13 // Реле выключение шарового крана солнечного коллектора, через доп реле.
		#define SUN_VALVE_SWITCH_TIME  25000 // Время переключения крана, мсек
	#endif
//	#define PIN_DEVICE_BATH_HEATER     33 // X37.2(EEV24) -> Relay(-12V)(+12V=X38.1) -> подает DA9(5V) -> провод -> реле 5V -> пускатель нагревателя
//  #define PIN_DEVICE_RSUPERBOILER    11 //[R_8] реле насоса супербойлера
//  #define PIN_DEVICE_RHEAT           12 //[R_9] Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.
//    #define PIN_DEVICE_R3WAY         13 //[R_10(X2)3.3V] 3-ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
//  #define PIN_DEVICE_RFAN1           11        // Реле включения вентилятора испарителя №1
//  #define PIN_DEVICE_RFAN2           11        // Реле включения вентилятора испарителя №2
//  #define PIN_DEVICE_REVI            11        // Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
//                                     Пины DUE 68, 69 не подключены к плате!

    // Имена индексов ВАЖЕН ПОРЯДОК!
    #define RCOMP              0          // Реле включения компрессора (через пускатель)
    #define RPUMPO             1          // Реле включения насоса выходного контура  (отопление и/или ГВС)
    #define RPUMPBH            2          // Реле насоса НАГРЕВА бойлера (ГВС) - не путать с циркуляцией
    #define RPUMPI             3          // Реле включения насоса входного контура  (геоконтур)
//    #define RBOILER            4          // Включение ТЭНа бойлера
//    #define R4WAY              5          // 4-ходовой реверсивный клапан (охлаждение)
//    #define RPUMPFL            6          // Реле насоса Теплого Пола
//	#define RSUN			   7		  // Реле включения солнечного коллектора
//	#define RBATH              8          // Реле включения отопителя ванной
//	#define RSUNON             9          // Реле открытия шарового крана солнечного коллектора
//	#define RSUNOFF            10         // Реле закрытия шарового крана солнечного коллектора
//   #define RRESET             6          // Выход для сброса инвертора
//   #define R3WAY              7          // Трех ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
//                                         // Если заремарен, то конфигурация с двумя насосами RPUMPO и RPUMPB. Работают по-очередно.
//   #define RSUPERBOILER       6          // реле насоса супербойлера
//   #define RFAN1              5          // Реле включения вентилятора испарителя №1
//   #define RFAN2              6          // Реле включения вентилятора испарителя №2
//   #define REVI               6          // Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
//   #define RHEAT              7          // Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.

	#define PUMP_OUT      RPUMPO			// Насос выходного контура (отопление)
	#define PUMP_IN       RPUMPI 			// Насос входного  контура (гео или воздушник)

	//#define RELAY_WAIT_SWITCH	11			// Заморозить выполнение задач на это время после переключения реле, ms

//   	#define CORRECT_POWER220				// Корректировка потребляемой мощности из электросети (и для расчета COP), если включены указанные реле, Вт
	#ifdef CORRECT_POWER220
    	CORRECT_POWER220_STRUCT correct_power220[] = { {RPUMPFL, 25} }; // Обороты: III = 45 Вт, II = 22 Вт, ТП-4 = 25
	#endif
//	#define STATS_SKIP_COP_WHEN_RELAY_ON 	RBOILER	// Пропускать логирование COP при включенном реле

   // Массив ног соглано индексов
   const uint8_t pinsRelay[RNUMBER] = { PIN_DEVICE_RCOMP,       // ++ Реле включения компрессора (через пускатель)
                                        PIN_DEVICE_RPUMPO,      // ++ Реле включения насоса выходного контура  (отопление и ГВС)
                                        PIN_DEVICE_RPUMPBH,     // ++ Реле насоса НАГРЕВА бойлера (ГВС) - не путать с циркуляцией
                                        PIN_DEVICE_RPUMPI      // ++ Реле включения насоса входного контура  (геоконтур)
                                      };
// Описание реле
  const char *noteRelay[RNUMBER] = { "Реле включения компрессора",
                                     "Реле включения насоса отопления",
                                     "Реле насоса нагрева бойлера",
                                     "Реле включения насоса геоконтура"
                                   };
   //  Имя реле
  const char *nameRelay[RNUMBER] = { "RCOMP",          // Реле включения компрессора
                                     "RPUMPO",         // Реле включения насоса отопления
                                     "RPUMPBH",        // Реле насоса НАГРЕВА бойлера (ГВС) - не путать с циркуляцией
                                     "RPUMPI"         // Реле включения насоса геоконтура
                                   } ;
   // #define R4WAY_INVERT     // Инвертирование четырехходового при этом получается: охлаждение - реле выключено, нагрев - включено (если дефайна нет то на оборот)

  // ДАТЧИКИ ТЕМПЕРАТУРЫ. СОТЫЕ ГРАДУСА ------------------------------------------------------------------------
  // наличие датчиков  датчиков от конфигурации минимальные максимальные и тестовые температуры
  // Температура хранится в сотых градуса
  // Нумерация датчиков
  // --------------------------------------------------------------------------------
  // ДАТЧИКИ и УСТРОЙСТВА - максимально поддерживаемые
  // --------------------------------------------------------------------------------
  #define TNUMBER     14    // Максимальное число температурных датчиков (то что поддерживается)
  //#define SENSOR_IP           // Использование удаленных устройств( датчиков температуры смотрим IPNUMBER )
  #define TNTC        9		// Количество датчиков NTC на DUE
  #define TNTC_EXT    4		// Количество датчиков NTC на внешнем АЦП
  #define IPNUMBER    0       // Максимальное число удаленных датчиков, запрет использования: заремарить SENSOR_IP, IPNUMBER = 0
//  #define RADIO_SENSORS_MAX 5

    #define TOUT        0    // Температура улицы
    #define TIN         1    // Температура в доме
    #define TBOILER     2    // Температура в бойлере ГВС
    #define TCOMP       3    // Температура нагнетания компрессора
    #define TEVAING     4    // Температура на входе ПТО геоконтура (по гликолю)
    #define TEVAOUTG    5    // Температура на выходе ПТО геоконтура (по гликолю)
    #define TCONING     6    // Температура на входе ПТО СО (по гликолю)
    #define TCONOUTG    7    // Температура на выходе ПТО СО (по гликолю)
    #define TEVAOUT     8    // Температура на выходе ПТО геоконтура (по фреону)
    #define TCONOUT     9    // Температура на выходе ПТО СО (по фреону)
	#define TSUN		10   // Температура солнечного коллектора (улица)
	#define TSUNOUTG	11   // Температура на выходе из СК (гликоль)
	#define TCOMPIN     12  // Температура на входе компрессора
    #define TEVAIN      13  // Температура на входе ПТО геоконтура (по фреону)
    // Датчики для информации:
    // Отсутствующие датчики:
    //#define TCONIN      0   // Температура на входе конденсатора (по фреону)
    //#define TACCUM      0   // Температура на выходе теплоаккмулятора
    // Наличие датчика в конфигурации: 0 - нет, >0 - есть, +2(бит_1) - выводить датчик отдельно внизу на странице "схема ТН" (если бит_0 = 0 - то только когда привязан)
    //                                                     +4(бит_2) - не строить график в ОЗУ
    //...................................0.....1.....2.....3.....4.....5.....6.....7.....8.....9....10....11....12....13..
    const uint8_t SENSORTEMP[TNUMBER]={    5,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    7,    7 };
    // минимальные значения температур
    const int16_t MINTEMP[TNUMBER] = { -4000,-1000,-1000,-1000,-2000,-2000,-2000,-2000,-2000,-2000,-4000,-2000,-2000,-3000 };
    // Макимальные значения температур, ВНИМАНИЕ! для TBOILER температура меняется если включен режим сальмонеллы на SALLMONELA_TEMP+300
    const int16_t MAXTEMP[TNUMBER] = {  9000, 9000, 9000, 8700, 9000, 9000, 6000, 6500, 9000, 9000,10000, 9000, 9000, 9000 };
    // Значения датчиков при тестировании, опция TEST
    const int16_t TESTTEMP[TNUMBER]= {  1000, 2200, 6000, 5000,  500,  100, 3000, 3500, -200, 3300, 2700, 3500, 2000, 2100 };
    // Ошибки датчиков (систематические) нужны для калибровки ОШИБКИ ДОБАВЛЯЮТСЯ!!! к значениям В СОТЫХ ГРАДУСА
    const int16_t ERRTEMP[TNUMBER]=  {     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0 };

    // NTC
	#define TEMP_TABLE_START	-5500
	#define TEMP_TABLE_STEP		500
	#ifdef TNTC
    // NTC, 10K, B3435, Таблица сопротивлений через 5°, (-55..125°), резистор 15k
    const uint16_t NTC_table[] = { 4008, 3972, 3924, 3863, 3784, 3688, 3570, 3432, 3272, 3094, 2898, 2690, 2475, 2257, 2042, 1835, 1638, 1456, 1288, 1136, 1000, 879, 773, 679, 597, 525, 463, 409, 361, 320, 284, 253, 226, 202, 181, 162, 146 };
    const int8_t TADC[TNTC]    = { 7, 6, 5, 4, 3, 2, 1, 0, 10 };
	#endif
	#ifdef TNTC_EXT
    const int8_t TADC_EXT[TNTC]= { 0, 1, 2, 3 };
	#endif

    // Имена датчиков
    const char *nameTemp[TNUMBER] = {
        "TOUT",             // 0. Температура улицы
        "TIN",              // 1. Температура в доме
        "TBOILER",          // 2. Температура в бойлере ГВС
        "TCOMP",            // 3. Температура нагнетания компрессора
        "TEVAING",          // 4. Температура на входе испарителя по гликолю
        "TEVAOUTG",         // 5. Температура на выходе испарителя по гликолю
        "TCONING",          // 6. Температура на входе конденсатора по гликолю
        "TCONOUTG",         // 7. Температура на выходе конденсатора по гликолю
        "TEVAOUT",          // 8. Температура на выходе испарителя по фреону
        "TCONOUT",           // 9. Температура на выходе конденсатора по фреону
		"TSUN",
		"TSUNOUTG",
		"TCOMPIN",
		"TEVAIN"
    };
    // Описание датчиков
    const char *noteTemp[TNUMBER] = {
        "Температура улицы",
        "Температура в доме",
        "Температура в бойлере ГВС",
        "Температура нагнетания компрессора",
        "Температура на входе из геоконтура",
        "Температура на выходе в геоконтур",
        "Температура на входе из отопления",
        "Температура на выходе в отопление",
        "Температура фреона на выходе ПТО гео",
        "Температура фреона на выходе ПТО дома",
		"Температура солнечного коллектора (улица)",
		"Температура на выходе из солнечного коллектора",
		"Температура перед ЭРВ", //"Температура фреона на входе ПТО гео",
		"Температура на входе компрессора"
    };

  #define TIME_READ_SENSOR  2000          // Период опроса датчиков (мсек)
  #define T_NUMSAMLES       3             // Число значений для усреднения показаний температуры
  #define GAP_TEMP_VAL      500           // Допустимая разница (в сотых C) показаний между двумя считываниями (борьба с помехами) - при привышении ошибка не возникает, но данные пропускаются.
  #define GAP_TEMP_VAL_CRC  200     	  // Датчики с флагом игнорировать CRC. Допустимая разница (в сотых C) показаний между двумя считываниями (борьба с помехами) - при привышении ошибка не возникает, но данные пропускаются.
  #define GAP_NUMBER        3       	  // Максимальное число идущих подряд показаний превышающих на GAP_TEMP_VAL, после этого эти показания выдаются за действительные
  #define GAP_NUMBER_CRC    7       	  // Датчики с флагом игнорировать CRC. Максимальное число идущих подряд показаний превышающих на GAP_TEMP_VAL, после этого эти показания выдаются за действительные

  // АНАЛОГОВЫЕ ДАТЧИКИ  -------------------------------------------------------------------
  #define ANUMBER		2       // Максимальное число аналоговых датчиков (то что поддерживается)
  // наличие датчиков в конфигурации минимальные максимальные и тестовые значения
  // Справочно нумерация датчиков
  // Давление харится в сотых бара
  #define PEVA			0                // Датчик давления испарителя.
  #define PCON			1                // Датчик давления конденсатора.
//  #define PGEO			2
//  #define POUT			3
  // Имена датчиков
  const char *nameAnalog[] = { "PEVA",
		  	  	  	  	  	  "PCON",
//							  "PGEO",
//							  "POUT"
                            };
  // Описание датчиков
  const char *noteAnalog[] = {"Датчик давления кипения",
                             "Датчик давления конденсации",
//  	  	  	  	  	  	  	 "Датчик давления геоконтура",
//							 "Датчик давления отопления"

  	  	  	  	  	  	  };

  // Номера каналов АЦП, в нумерации SAM3X (AD*):
  #define ADC_SENSOR_PEVA		13		// датчик давления испарителя
  #define ADC_SENSOR_PCON		12		// датчик давления конденсатора
//  #define ADC_SENSOR_PGEO		4		// датчик давления геоконтура - желтый, красный "+5V", черный "-".
//  #define ADC_SENSOR_POUT		5		// датчик давления отопления - желтый, красный "+5V", черный "-".
  // Коэффициент преобразования отсчеты АЦП-давление, тысячные
  const uint16_t TRANsADC[ANUMBER]  = { 373,  1380  };
  // напряжение (отсчеты АЦП) соответсвующее cZero
  const uint16_t ANALOG_ZERO[ANUMBER] = { 290,   740  };

  const boolean ANALOG_SENSORS[ANUMBER]= {    1,     1  };	// Присутствие датчика в конфигурации
  const int16_t ANALOG_MIN[ANUMBER]   = {   30,   100  };	// минимальные значения давления, в сотых бар
  const uint16_t ANALOG_MAX[ANUMBER]  = {  700,  2000  };	// Максимальные значения давления, в сотых бар
  const uint16_t ANALOG_TEST[ANUMBER] = {  150,   800  };	// Значения датчиков при тестировании  опция TEST, в сотых бар
  //#define ANALOG_MODBUS 									// Данные аналоговых датчиков читаются по Modbus RTU
  #ifdef ANALOG_MODBUS
	  #define ANALOG_MODBUS_NUM_READ				3			// Число попыток чтения
	  #define ANALOG_MODBUS_ERR_DELAY				50			// Задержка при ошибки чтения
	  const uint16_t ANALOG_MODBUS_ADDR[ANUMBER] = { 1, 1 };	// Адрес устройства Модбас, если 0, то датчик обычный.
  	  const uint16_t ANALOG_MODBUS_REG[ANUMBER]  = { 60, 59 };	// Регистр Модбас, по которому доступно значение датчика. Для Vacon=(AI2, AI1)
  #endif
  // ------------------- ADC SENSOR ----------------------------------
  #define ADC_PRESCAL		9			// = (42 / ADCClockMhz - 1), - 4.2 MHz
  #define ADC_SKIP_EXTREMUM 300			// Отбрасывать максимумы/минимумы больше заданной дельты
  #define P_NUMSAMLES       1			// Число значений для усреднения показаний давления
  #define ADC_FREQ          3			// период опроса аналоговых датчиков в секунду
  #define FILTER_SIZE       50			// Длина фильтра для датчиков давления
  #define FILTER_SIZE_OTHER 2			// Длина фильтра для остальных датчиков

  // Конфигурация системы отопления --------------------------------------------------------------------------------
  // от куда брать температуру обратки и подачи системы отопления смотртеть кондесатор.
  // Могут быть задействованы разные датчики!
  #define FEED      sTemp[TCONOUTG].get_Temp()       // Подача системы CO
  #define RET       sTemp[TCONING].get_Temp()        // Обратка системы CO

  // Графики в памяти
	Charts_Mod_setup ChartsModSetup[] = {
		{ STATS_OBJ_Temp, TOUT },
		{ STATS_OBJ_Temp, TIN },
		{ STATS_OBJ_Temp, TBOILER },
		{ STATS_OBJ_Temp, TCOMP },
		{ STATS_OBJ_Temp, TEVAING },
		{ STATS_OBJ_Temp, TEVAOUTG },
		{ STATS_OBJ_Temp, TCONING },
		{ STATS_OBJ_Temp, TCONOUTG },
		{ STATS_OBJ_Temp, TEVAOUT },
		{ STATS_OBJ_Temp, TCONOUT },
		{ STATS_OBJ_Temp, TSUN },
		{ STATS_OBJ_Temp, TSUNOUTG },
		{ STATS_OBJ_Flow, FLOWEVA },
		{ STATS_OBJ_Flow, FLOWCON },
//		{ STATS_OBJ_Press, PGEO },
//		{ STATS_OBJ_Press, POUT },
		{ STATS_OBJ_PressTemp, PEVA },
		{ STATS_OBJ_PressTemp, PCON }
	};
	const Charts_Const_setup ChartsConstSetup[] = {
		{ STATS_OBJ_EEV, "ЭРВ" },
		{ STATS_OBJ_Overheat, "Перегрев" },
		{ STATS_OBJ_Overheat2, "Перегрев на входе компрессора" },
		{ STATS_OBJ_Compressor, "Частота, Гц" },
//		{ STATS_OBJ_Power_FC, "Мощность компрессора" },
		{ STATS_OBJ_Power, "Потребляемая мощность" },
		{ STATS_OBJ_COP_Full, "COP" }
	};
	const Charts_Const_setup ChartsOnFlySetup[] = {
		{ STATS_OBJ_Overcool, "Переохлаждение" }, // T[PCON] - TCONOUT
		{ STATS_OBJ_TCOMP_TCON, "Нагнетание - Конденсация" }, // TCOMP - TCON
		{ STATS_OBJ_Delta_GEO, "Дельта температур геоконтура" }, // TEVAING - TEVAOUTG
		{ STATS_OBJ_Delta_OUT, "Дельта температур выхода" }, // TCONOUTG - TCONING
		{ STATS_OBJ_Power_GEO, "Мощность геоконтура" }, // (TEVAOUTG - TEVAING) * FLOWEVA / kfCapacity
		{ STATS_OBJ_Power_OUT, "Выходная мощность" } // (TCONOUTG - TCONING) * FLOWCON / kfCapacity
	};

  // История (графики)
	const History_setup HistorySetup[] = {
		{ STATS_OBJ_Compressor, 0, "Компрессор, Гц" },
		{ STATS_OBJ_Temp, TOUT, noteTemp[TOUT] },
		{ STATS_OBJ_Temp, TIN, noteTemp[TIN] },
		{ STATS_OBJ_Temp, TBOILER, noteTemp[TBOILER] },
		{ STATS_OBJ_Temp, TCOMP, noteTemp[TCOMP] },
		{ STATS_OBJ_Temp, TEVAING, noteTemp[TEVAING] },
		{ STATS_OBJ_Temp, TEVAOUTG, noteTemp[TEVAOUTG] },
		{ STATS_OBJ_Temp, TCONING, noteTemp[TCONING] },
		{ STATS_OBJ_Temp, TCONOUTG, noteTemp[TCONOUTG] },
		{ STATS_OBJ_Temp, TEVAOUT, noteTemp[TEVAOUT] },
		{ STATS_OBJ_Temp, TCONOUT, noteTemp[TCONOUT] },
		{ STATS_OBJ_Temp, TSUN, noteTemp[TSUN] },
		{ STATS_OBJ_Temp, TSUNOUTG, noteTemp[TSUNOUTG] },
		{ STATS_OBJ_PressTemp, PEVA, "Температура кипения" },
		{ STATS_OBJ_PressTemp, PCON, "Температура конденсации" },
		{ STATS_OBJ_Flow, FLOWEVA, noteFrequency[FLOWEVA] },
		{ STATS_OBJ_Flow, FLOWCON, noteFrequency[FLOWCON] },
		{ STATS_OBJ_EEV, STATS_EEV_Percent, "Положение ЭРВ, %" },
		{ STATS_OBJ_EEV, STATS_EEV_OverHeat, "Перегрев" },
		{ STATS_OBJ_EEV, STATS_EEV_OverCool, "Переохлаждение" },
		{ STATS_OBJ_Power, 0, "Потребление, кВт" },
		{ STATS_OBJ_Power_OUT, 0, "Выработка, кВт" },
		{ STATS_OBJ_COP_Full, 0, "COP" }
	};

  #define PID_FORMULA2							// Адаптированный алгоритм ПИД Arduino-PID-Library
  // ------------------- EEV -----------------------------------
  // ЭРВ ТОЛЬКО ОДНА ШТУКА ВСЕГДА (не массив) ------------------
  #define EEV_DEF                     // Наличие ЭРВ в конфигурации
  #ifdef EEV_DEF                                  // ЭРВ настройки
    //  Константы (из программы не меняются)
	#define EEV_STEPS              480            // Число шагов ЭРВ 480
	#define EEV_CLOSE_STEP         0              // ЭРВ закрыт
	#define EEV_QUEUE              10             // Длина очереди команд шагового двигателя ЭРВ
	#define EEV_PHASE              PHASE_8s       // ЗАДАННАЯ (можно менять) последовательность (шагов) при движении ЭРВ
	#define EEV_SET_ZERO_OVERRIDE  4			  // Добавка к полному закрытию при установке нуля, шаги
    //#define EEV_INVERT                          // Признак инвертирования движения ЭРВ  (меняем если крутит в обратную сторону)
	//#define EEV_MIN_CONTROL                     // Контроль нижней границы ЭРВ - останов по ошибке.
    //#define EEV_MAX_CONTROL                     // Контроль верхней границы ЭРВ - останов по ошибке.
      
	#define FREON                  R410A 		  // Тип фреона
	// Значения по умолчанию
	#define DEFAULT_RULE_EEV       TEVAOUT_PEVA	  // Формула по умолчанию - TEVAOUT_PEVA
	#define DEFAULT_EEV_TIME	   8			  // Постоянная интегрирования времени в секундах ЭРВ СЕКУНДЫ
	#define DEFAULT_OVERHEAT       125			  // Перегрев по умолчанию (сотые градуса)
	#define DEFAULT_EEV_Kp	       200			  // ПИД Коэф пропорц.  В СОТЫХ
	#define DEFAULT_EEV_Ki	       50			  // ПИД Коэф интегр.   В СОТЫХ
	#define DEFAULT_EEV_Kd	       500			  // ПИД Коэф дифф.   В СОТЫХ
    #define DEFAULT_ERR_KP         100.0          // Ошибка (в сотых градуса) при которой происходит уменьшение пропорциональной составляющей ПИД ЭРВ
    #define DEFAULT_SPEED_EEV      31             // Скорость шагового двигателя ЭРВ (импульсы в сек.)
    #define DEFAULT_PRE_START_POS  300            // ПУСКОВАЯ позиция ЭРВ (ТО что при старте компрессора ПРИ РАСКРУТКЕ)
    #define DEFAULT_START_POS      250            // СТАРТОВАЯ позиция ЭРВ после раскрутки компрессора т.е. ПОЗИЦИЯ С КОТОРОЙ НАЧИНАЕТСЯ РАБОТА проходит DelayStartPos сек
    #define DEFAULT_HOLD_MOTOR     false          // Режим "удержания" шагового двигателя ЭРВ
	#define EEV_PREFER_PERCENT					  // Предпочтительно положение ЭРВ в %. (Для графиков и т.п.)
	// Корректировки для фреона R410a
	#define DEF_OHCor_OverHeatStart 	100		  	// Начальный перегрев (сотые градуса)
	#define DEF_OHCor_OverHeatMin 		50    		// Минимальный перегрев (сотые градуса)
	#define DEF_OHCor_OverHeatMax 		250    		// Максимальный перегрев (сотые градуса)
	#define DEF_OHCor_TDIS_TCON			2400        // Разница температура нагнетания - конденсации(при 30С) и 0С кипении и перегреве OHCor_OverHeatStart (в сотых)
	//#define DEF_OHCor_TDIS_TCON_Thr 	300		    // Порог, после превышения TDIS_TCON + TDIS_TCON_Thr начинаем уменьшать перегрев (в сотых)
  	#define DEF_OHCor_CONDENSING_30_MUL 57			// Корректировка разницы Нагнетание-Конденсация на кажлые 10 градусов конденсации от 30 (в сотых), зависит от фреона
	#define DEF_OHCor_EVAPORATING_0_MUL 86			// Корректировка разницы Нагнетание-Конденсация на кажлые -10 градусов кипения от 0 (в сотых), зависит от фреона
	#define DEF_OHCor_Delay 			300         // Задержка после старта компрессора, сек
	#define DEF_OHCor_Period 			10		    // Период в циклах ЭРВ, сколько пропустить
	#define DEF_OHCor_MAX_STEP			200			// Максимальное изменение перегрева за раз, в сотых градуса

  	// ЭРВ Времена и задержки
    #define DEFAULT_DELAY_ON_PID    30            // Задержка начала регулирования от пуска компрессора, сек. Общее время =delayOnPid+DelayStartPos
    #define DEFAULT_DELAY_ON        3             // Задержка между открытием (для старта) ЭРВ и включением компрессора, для выравнивания давлений (сек). Если ЭРВ закрывлось при остановке
    #define DEFAULT_DELAY_START_POS 5             // Время после старта компрессора когда EEV выходит на стартовую позицию - облегчение пуска вначале ЭРВ
    #define DEFAULT_DELAY_OFF       3             // Задержка закрытия EEV после выключения насосов (сек). Время от команды стоп компрессора до закрытия ЭРВ = delayOffPump+delayOff
  #endif

     // Частотный преобразователь ТОЛЬКО ОДНА ШТУКА ВСЕГДА (не массив) --------------------------------------------------------
  const boolean DEVICEFC=true;  // Наличие Частотного преобразователя в конфигурации
  #define FC_VACON        // Частотник Vacon
	// Настройка, параметр(регистр Modbus):
  	// Vacon 10/20: V2.2 = 1; V2.3 = 1; V2.4 = 1; P2.1(172) = 0; P3.3(173) = 3; P5.1(403) = 1;
    //				Мин.частота: P3.1(101) = 4000; Макс.частота: P3.2(102) = 7000
    // Vacon 20: P10.8(859) = 8
    // Константы частотного преобразователя для конкртеной  реализации
    //#define FC_CORRECT_NOMINAL_POWER -70			// Корректировка расчетной номинальной мощности по ячейкам модбас = [#110] * [#113] * [#120] * 173/1000000, Вт
	#define FC_USE_RCOMP                            // Использовать для разрешения работы инвертора отдельный выход RCOMP (Vacon FB 172=0)
													// Используется дискретный вход частотника (0..30V), прописанный в ячейке P5.7 "Работа разрешена" (modbus #407)
    #define FC_ANALOG_CONTROL						// Использование аналогового управления частотником, Для использования 485 закоментировать эту строку
	#define PIN_DEVICE_FC			 2  			// Выход PWM или DACx
	#define FC_ANALOG_OFF_SET_0						// Устанавливать выход PIN_DEVICE_FC в 0 при останове компрессора
	// Значения по умолчанию (начало DEF_) не Константы
	#define DEF_FC_UPTIME            (5)            // Время обновления алгоритма пид регулятора (сек) Основной цикл управления
    #define DEF_FC_DT_COMP_TEMP      (5*100)        // Защита по температуре компрессора - сколько градусов не доходит до максимальной (TCOMP) и при этом происходит уменьшение частоты
	#define DEF_FC_PID_FREQ_STEP     (2*100)        // Максимальный шаг (на увеличение) изменения частоты при ПИД регулировании в 0.01 Гц Необходимо что бы ЭРВ успевал
	#define DEF_FC_PID_STOP          90             // Проценты от уровня защит (мощность, ток, давление, темпеартура) при которой происходит блокировка роста частоты пидом
	#define DEF_FC_PID_P_ON_M        false		    // Режим ПИДа отопления, бойлера - true пропорционально измерению, false - пропорционально ошибке
	#define DEF_FC_START_FREQ        (30*100)       // Стартовая скорость инвертора (см компрессор) в 0.01 %
	#define DEF_FC_START_FREQ_BOILER (30*100)       // Стартовая скорость инвертора (см компрессор) в 0.01 % ГВС
	#define DEF_FC_MIN_FREQ          (10*100)       // Минимальная  скорость инвертора (см компрессор) в 0.01 %
	#define DEF_FC_MIN_FREQ_COOL     (10*100)       // Минимальная  скорость инвертора при охлаждении в 0.01 %
	#define DEF_FC_MIN_FREQ_BOILER   (10*100)       // Минимальная  скорость инвертора при нагреве ГВС в 0.01 %
	#define DEF_FC_MIN_FREQ_USER     (1*100)        // Минимальная  скорость инвертора РУЧНОЙ РЕЖИМ (см компрессор) в 0.01 %
	#define DEF_FC_MAX_FREQ          (60*100)       // Максимальная скорость инвертора (см компрессор) в 0.01 %
	#define DEF_FC_MAX_FREQ_COOL     (30*100)       // Максимальная скорость инвертора в режиме охлаждения  в 0.01 %
	#define DEF_FC_MAX_FREQ_BOILER   (30*100)       // Максимальная скорость инвертора в режиме ГВС в 0.01 Гц поглощение бойлера обычно меньше чем СО
	#define DEF_FC_MAX_FREQ_USER     (150*100)      // Максимальная скорость инвертора РУЧНОЙ РЕЖИМ (см компрессор) в 0.01 %
	#define DEF_FC_STEP_FREQ         (2*100)        // Шаг уменьшения инвертора при достижении максимальной температуры, мощности и тока (см компрессор) в 0.01 %
	#define DEF_FC_STEP_FREQ_BOILER  (2*100)        // Шаг уменьшения инвертора при достижении максимальной температуры, мощности и тока ГВС в 0.01 %
	#define DEF_FC_DT_TEMP           (1*100)        // Привышение температуры от уставок (подача) при которой срабатыват защита (уменьшается частота) в сотых градуса
	#define DEF_FC_DT_TEMP_BOILER    (2*100)        // Привышение температуры от уставок (подача) при которой срабатыват защита ГВС в сотых градуса
    // КОНСТАНТЫ
	#define FC_DT_CON_PRESS           50            // Защита по давлению компрессора - сколько сотых бара не доходит до максимальной (PCON) и при этом происходит уменьшение частоты
	#define FC_MAX_POWER             (4000)         // Максимальная мощность инвертора (см компрессор) в Вт
	#define FC_MAX_POWER_BOILER      (4000)         // Максимальная мощность инвертора в режиме ГВС (см компрессор) в Вт
	#define FC_MAX_CURRENT           (10*100)       // Максимальный ток инвертора (см компрессор) в 0.01 А
	#define FC_MAX_CURRENT_BOILER    (10*100)       // Максимальный ток инвертора для ГВС в 0.01 А
	#define FC_ACCEL_TIME			 (3*10)			// Время разгона компрессора в сотых сек
	#define FC_DEACCEL_TIME          (2*100)   	  	// Время торможения компрессора в сотых сек
    #define FC_START_PID_DELAY       (40*100)      	// Задержка ПИД после старта компрессора

	#define FC_RETOIL_FREQ			  4500		    // Частота меньше которой должен происходить возврат масла, в сотых Гц
	#define FC_RETOIL_TIME			 (16/(FC_TIME_READ/1000)) // Время возврата, сек

	#define COP_ALL_CALC   // Проводить расчет КОП всегда, если дефайна нет, то КОП считается ТОЛЬКО при работающем компрессоре, в паузах ставится 0

     // Временные задержки (опции) Значения по умолчанию (начало DEF_)
    #define DEF_DELAY_ON_PUMP    	  	15             // Задержка включения компрессора после включения насосов (сек).
    #define DEF_DELAY_OFF_PUMP    		90             // Задержка выключения насосов после выключения компрессора (сек).
    #define DEF_DELAY_START_RES   		(5*60)         // Задержка включения ТН после внезапного сброса контроллера (сек.)
    #define DEF_DELAY_REPEAD_START 		(10*60)        // Задержка перед повторным включениме ТН при ошибке (попытки пуска) секунды
    #define DEF_DELAY_DEFROST_ON 		120            // ДЛЯ ВОЗДУШНОГО ТН Задержка после срабатывания датчика перед включением разморозки (секунды)
    #define DEF_DELAY_DEFROST_OFF		120            // ДЛЯ ВОЗДУШНОГО ТН Задержка перед выключением разморозки (секунды)
    #define DEF_DELAY_R4WAY        		20             // Задержка между переключением 4-х ходового клапана и включением компрессора, для выравнивания давлений (сек). Если включены эти опции (переключение тепло-холод)
    #define DEF_DELAY_BOILER_SW   		15             // Пауза (сек) после переключение ГВС - выравниваем температуру в контуре отопления/ГВС что бы сразу защиты не сработали
    #define DEF_DELAY_BOILER_OFF 		30             // Время (сек) на сколько блокируются защиты при переходе с ГВС на отопление и охлаждение слишком горяче после ГВС
	#define DELAY_AFTER_SWITCH_RELAY    250            // Задержка после переключения реле, для сглаживания потребления и уменьшения помех(мс)
	#define DELAY_BEFORE_STOP_IN_PUMP	15			   // Задержка перед выключением насоса геоконтура, насос отопления отключается позже (сек)

#endif  // CONFIG_6      


// -----------------------------------------------------------------------------------------------------------------------------------
// =============================================== C O N F I G   7 ===================================================================
// -----------------------------------------------------------------------------------------------------------------------------------
#ifdef CONFIG_7    // Имя и описание конфигурации и ОСОБЕННОСТИ конфигурации ---------------------------------------------------------
//	#define TEST_BOARD 				// Тестовая плата!

	#define CONFIG_NAME   "vad7"
	#define CONFIG_NOTE   "Частотник, 3 фазы, охлаждение, ЭРВ, РТО, СК, ТП"
	// Danfoss HLP068T4LC6, Vacon 10 (12A), ПТО: B3-052-46-HQ, РТО: HE 4.0, ЭРВ: ETS 6-25
	// Геоконтур: 6x50м ПНД50/ПП20 коаксил, Солнечный Коллектор: 6х50м ПНД 20.
	#define HP_SCHEME     3			// Номер схемы который выводится на морде, подмена файлов plan[HPscheme].png -> plan1.png
	#define UART_SPEED    250000	// Скорость отладочного порта
	#define KEY_ON_OFF				// + KEY1 Наличие кнопки включения и переключения в safeNetwork (нажата при сбросе)
	#define SPI_FLASH				// + Наличие чипа флеш памяти на шине SPI
	#define LOAD_VERIFICATION     	// Признак чтения настроек c проверкой версии, длины, CRC16. Закоментируйте эту строку для ПОПЫТКИ загрузить старый формат, Запись всегда идет в новом
	#define CHART_ONLY_COMP_ON      // Накопление точек для графиков ТОЛЬКО если компрессор работает, иначе всегда (и в паузах тоже) когда ТН включен
	//#define CLEAR_CHART_HP_ON      // Очистка графиков при страте ТН
	#define NEXTION                 // Разрешить использование дисплея. ЗАКОМЕНТИРУЙТЕ эту строку, что бы не использовать дисплей
	#ifdef 	NEXTION
	//#define NEXTION_GENERATOR   // На дисплее кнопкой можно переключать "Работа от генератора" (ограничение мощности потребления)
	#define NEXTION_SCR0_DIS_ON_OFF	// Отключить реакцию на кнопку Вкл/Выкл на главном экране, есть еще одна кнопка Вкл/Выкл на экране Профили.
	#endif
	#define EXTERNAL_AREF     	  	// Использование внешней опоры для АЦП
	#ifdef EXTERNAL_AREF        	// Какая опора для АЦП используется
	  #define SAM3X_ADC_REF  3.00   // Используется внешняя опора ADR4530ARZ
	#else
	  #define SAM3X_ADC_REF  3.30   // Штатное подключение используется питание DUE
	#endif
	#define USE_ELECTROMETER_SDM    // + Наличие счетчика SDM
	#define USE_SDM630        	  	// Наличие счетчика SDM630 - 3 фазы
	#define SDM_VOLTAGE      4		// Ячейка напряжения
	//#define USE_PZEM004T			// Наличие электросчетчика PZEM-004T v3 Modbus/UART
	#define ADD_FC_POWER_WHEN_GENERATOR // Прибавлять расчитанную мощность частотника к показаниям счетчика, когда работа через генератор
	#define USE_UPS					// Используется ИБП на контроллер, проверка через вход SPOWER
	#define AUTO_START_GENERATOR 30 // Автозапуск генератора (реле RGEN), ждать секунд (для прогрева)
	#define AUTO_START_GEN_TIMEOUT 200 // Таймаут ожидания старта генератора, сек
	#define STATS_USE_BUFFER_FOR_SAVING // Сохранять статистику только когда буфер (512 байт) заполнен, иначе каждый день
	#define MIN_RAM_CHARTS

	#define ONEWIRE_DS2482			// + Использование мастера i2c Onewire DS2482 (адрес AD1,0 = 0,0)
	#define ONEWIRE_DS2482_SECOND	// второй мастер i2 Onewire DS2482 (адрес AD1,0 = 0,1)
	#define ONEWIRE_DS2482_THIRD	// третий мастер i2 Onewire DS2482 (адрес AD1,0 = 1,0)
	#define ONEWIRE_DS2482_FOURTH	// четвертый мастер i2 Onewire DS2482 (адрес AD1,0 = 1,1)
	#define ONEWIRE_DS2482_2WAY  	// Используются 2-х проводные шины OneWire (паразитное питание)
	#ifdef ONEWIRE_DS2482_2WAY
	  const uint8_t ONEWIRE_2WAY = 0b1010; // На каких шинах (4|3|2|1) двух-проводные датчики, битовая маска
	#else
	  const uint8_t ONEWIRE_2WAY = 0b0000;
	#endif
	//	#define PIN_ONE_WIRE_BUS   23       // X23-X24. нога с интерфейсом программный OneWire ВСЕ температурные датчики

	#define USE_SUN_COLLECTOR			// Используется солнечный/воздушный коллектор (работает при включенном ТН постоянно, если позволяет температура)
	#define SUN_TDELTA			300		// Дельта температур для включения, сотые градуса, по умолчанию
	#define SUNG_TDELTA			200		// Дельта температур жидкости для выключения, сотые градуса, по умолчанию
	#define SUN_MIN_WORKTIME	120		// минимальное время работы, после которого будут проверятся границы, сек, по умолчанию
	#define SUN_MIN_PAUSE		900		// минимальное время паузы после останова СК, сек, по умолчанию

	#define RADIO_SENSORS			// Радиодатчики через ZONT МЛ‑489.
	// Подключение через плату UART - K-line или через 4 платы UART-RS485 отдельно на RX и TX, на стороне МЛ-489 : питание 5V, через диод K-line >--TX--|>|--RX
	// Новый датчик ждем в течении 2-х минут после старта НК (нажать кнопку датчика пока не загорится его светодиод)
	#define RADIO_SENSORS_PORT		2				// Номер Serial
	#define RADIO_SENSORS_PSPEED	115200			// Скорость порта
	#define RADIO_SENSORS_PCONFIG	SERIAL_8N1		// Конфигурация порта

	//#define USE_SERIAL4							// Использовать порт Serial4 на D52(RXD2) и A11/D62(TXD2)

	#ifdef TEST_BOARD
		#define DEBUG                   // В последовательный порт шлет сообщения в первую очередь ошибки
	//	#define DEBUG_NATIVE_USB		// Отладка через второй USB порт (Native)
		#define DEBUG_MODWORK           // Вывод в консоль состояние HP при работе
	//  #define NEXTION_DEBUG 			// Отладка дисплея Nextion
	//	#define DEBUG_PID				// Отладка ПИДа
		#define I2C_FRAM_MEMORY  0		// 1 - FRAM память
		#undef ONEWIRE_DS2482
		#undef ONEWIRE_DS2482_SECOND
		#undef ONEWIRE_DS2482_THIRD
		#undef ONEWIRE_DS2482_FOURTH
		#undef ONEWIRE_DS2482_2WAY
		#define PIN_ONE_WIRE_BUS   41   // нога с интерфейсом программный 1-Wire - ВСЕ температурные датчики
	#else
		#define DEBUG                   // В последовательный порт шлет сообщения в первую очередь ошибки
		//#define DEBUG_NATIVE_USB		// Отладка через второй USB порт (Native)
		//#define DEBUG_MODWORK           // Вывод в консоль состояние HP при работе
		//#define DEBUG_PID				// Отладка ПИДа
		#define DEBUG_RADIO				// Отладка радиодатчиков
		#define I2C_EEPROM_64KB	        // Использование памяти I2C для записи журнала при коментарии используется оперативка
		#define I2C_FRAM_MEMORY  1		// 1 - FRAM память
		//#define DONT_LOG_SUCCESS_PING	// Не логировать в журнал успешные пинги
	#endif
	#ifdef  I2C_EEPROM_64KB                    // В зависимости от типа чипа
		#define I2C_ADR_EEPROM    0x50         // Адрес чипа на шине I2C
		#define I2C_SIZE_EEPROM   512    	   // Объем чипа в килобитах
		#define I2C_MEMORY_TOTAL  1024   	   // Итоговый размер I2C памяти в килобитах
		#define I2C_PAGE_EEPROM   64           // Размер страницы для чтения, байты
	#else // все остальное
		#define I2C_ADR_EEPROM    0x57         // Адрес чипа на шине I2C
		#define I2C_SIZE_EEPROM   32	       // Объем чипа в килобитах
		#define I2C_MEMORY_TOTAL  I2C_SIZE_EEPROM // Итоговый размер I2C памяти в килобитах
		#define I2C_PAGE_EEPROM   32           // Размер страницы для чтения, байты
	#endif
	#define REBOOT_ON_I2C_ERRORS				// Soft RESET при постоянной ошибке I2C

	//#define MQTT                             // признак использования MQTT, при неиспользовании необходимо закоментировать
	
	// FREE RTOS  Размеры стеков задач -----------------------------------------------
	#define STACK_vUpdateCommand  174                              // Стек задачи выполнение команд управления (разбор очереди комманд)
	#define STACK_vWebX           178                              // Стек задачи веб морды один поток (потоков может быть 1-4)

	#ifdef  TEST_BOARD
		#define SD_CLOCK				20	// частота SPI для SD карты в МГц
		// СЕТЕВЫЕ НАСТРОЙКИ --------------------------------------------------------------
		uint8_t SPI_RATE 			  = 4;	// делитель для SPI шины, 2=42MHz, 3=28MHz, 4=21MHz, 6=14MHz
		const boolean   defaultDHCP	=	false;
		const IPAddress defaultIP		(192, 168, 0, 199);
		const IPAddress defaultGateway	(192, 168, 0, 10);
		const IPAddress defaultSDNS		(8, 8, 8, 8);
	#else
		#define SD_CLOCK				28	// частота SPI для SD карты в МГц
		// СЕТЕВЫЕ НАСТРОЙКИ --------------------------------------------------------------
		uint8_t SPI_RATE 			  = 2;	// делитель для SPI шины, 2=42MHz, 3=28MHz, 4=21MHz, 6=14MHz
		const boolean   defaultDHCP	=	false;
		const IPAddress defaultIP		(192, 168, 0, 7);
		const IPAddress defaultGateway	(192, 168, 0, 1);
		const IPAddress defaultSDNS		(8, 8, 8, 8);
	#endif
	const IPAddress defaultSubnet      (255, 255, 255, 0);
	 //  #define SUPERBOILER               // Использование предкондесатора для нагрева ГВС
	 //  #define SUPERBOILER_FC (90*100)   // частота супербойлера для частотника
	 //  #define SUPERBOILER_DT (10*100)   // разница температур компресссора и бойлера для включения насоса
	// --------------------------------------------------------------------------------
	// ЖЕЛЕЗО  - привязка к ногам контроллера  В зависимости от конкретной схемы и платы
	// Для каждой конфигурации теперь свои определения!!!
	// --------------------------------------------------------------------------------
	// Конфигурирование Modbus для инвертора и счетчика SDM
	#define MODBUS_PORT_NUM         Serial3     // Аппаратный порт куда прицеплен Modbus
	#define MODBUS_PORT_SPEED       9600        // Скорость порта куда прицеплен частотник и счетчик
	#define MODBUS_PORT_CONFIG      SERIAL_8N1  // Конфигурация порта куда прицеплен частотник и счетчик
	#define MODBUS_TIME_WAIT        1000        // Время ожидания захвата мютекса для modbus мсек
	#define MODBUS_TIME_TRANSMISION 0           // Пауза (msec) между запросом и ответом по модбас было 4
	//#define PIN_MODBUS_RSE          22          // Не используется из-за платы UART-RS485! Управление направлением передачи 485 для связи с инвертором по Modbus (1-передача 0-прием)
	#define SDM_READ_PERIOD     	30000       // Время опроса счетчика, не важных параметров (0 - нет), в ms
	#define SDM_NUM_READ        	2           // Число попыток чтения счетчика (подряд) по модбас до его отключения (ошибка не генерится)

	// Защиты по входному напряжению. Используется счетчик SDM*
	//#define SDM_MIN_VOLTAGE     120.0          // Минимальное напряжение работы ТН при падении - предупреждение
	//#define SDM_MAX_VOLTAGE     265.0          // Максимальное напряжение работы ТН при падении - выключение ТН
	#define SDM_MAX_POWER       7500.0         // Максимальная мощность потребления (ватт) - выключение ТН

	// SPI шина управление отдельными устройствами до 3-х устройств (активный уровень низкий)
	#define PIN_SPI_CS_W5XXX   10			// ETH-CS   сигнал CS управление сетевым чипом w5500
	#define PIN_SPI_CS_SD	   4			// SD-CS    сигнал CS управление SD картой
	#define PIN_SPI_CS_FLASH   52			// (67) FLASH-CS сигнал CS управление чипом флеш памяти (D52 пересекается с Serial4!)

	// Сервис
	#define PIN_ETH_RES        8         // ETH-RES Сброс сетевого чипа w5500 активный low нормально high
	//#define PIN_ETH_INT      3         // ETH-INT Прерывание с w5500 пока не используется надо програмировать на вход
	#define PIN_LED1           42        // LED1 Первый красный светодиод для контроля (питание и фатальная ошибка freeRTOS)
	#define PIN_LED_ERROR      PIN_LED1  // Для библиотеки FreeRTOS
#ifdef TEST_BOARD
	#define PIN_LED_OK         13        // Зеленый светодиод Выход на светодиод мигает 0.5 герца - ОК  с частотой 2 герца ошибка
#else
	#define PIN_LED_OK         43        // Зеленый светодиод Выход на светодиод мигает 0.5 герца - ОК  с частотой 2 герца ошибка
#endif
	#define PIN_KEY1           44        // KEY1 Первая кнопка (ТН вкл/вкл) Нажатие при включении - режим safeNetwork (настрока сети по умолчанию 192.168.0.177  шлюз 192.168.0.1, не спрашивает пароль на вход в веб морду)
	#define PIN_BEEP           45        // Выход на пищалку

	// EEV куда подключено общий СИНИЙ
	#define PIN_EEV1_D24       29  //[X40.1(от надписи)] // 1 нога ЭРВ +А ОРАНЖЕВЫЙ - коричневый
	#define PIN_EEV2_D25       30  //[X40.2]             // 2 нога ЭРВ +B КРАСНЫЙ - желтый
	#define PIN_EEV3_D26       31  //[X40.3]             // 3 нога ЭРВ -A ЖЕЛТЫЙ - зеленый
	#define PIN_EEV4_D27       32  //[X41.1(от надписи)] // 4 нога ЭРВ -B ЧЕРНЫЙ - белый
								   //[X41.2]             // 5 нога ЭРВ Об.+12V СЕРЫЙ - экран

	// ЭРВ 2 (дополнительный испаритель, воздушка) - требуется четыре провода  Общий синий (пока не поддерживается прошивкой)
	// #define PIN_DEVICE_EEV_ORANGE 24    // + Фаза А    оранжевый (пока не поддерживается прошивкой)
	// #define PIN_DEVICE_EEV_YELLOW 25    // + Фаза ~А   желтый    (пока не поддерживается прошивкой)
	// #define PIN_DEVICE_EEV_RED    26    // + Фаза B    красный   (пока не поддерживается прошивкой)
	// #define PIN_DEVICE_EEV_BLACK  27    // + Фаза ~B   Черный    (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_12V1  28  // 12в силовой выход с ULN2003 (3 выхода в параллель) (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_12V2  33  // 12в силовой выход с ULN2003 одинарный  (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_12V3  34  // 12в силовой выход с ULN2003 одинарный (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_12V4  35  // 12в силовой выход с ULN2003 одинарный (пока не поддерживается прошивкой)
	// выходы 0-10в
	// #define PIN_DEVICE_FC        DAC0  // ++ DAC0  //Частотный преобразователь, выход 0-10в
	//#define PIN_DEVICE_FC2        DAC1  // ++ DAC1   //Частотный преобразователь2, выход 0-10в (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_PWM1       2  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_PWM1       5  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_PWM1       6  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
	//#define PIN_DEVICE_PWM1       7  // ++ управление насосом выход 0-10в (пока не поддерживается прошивкой)
	// датчики

	// Контактные датчики ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
	#define INUMBER             3   // Максимальное число контактных датчиков цифровые входы (то что поддерживается)
	//  Ноги куда прицепленны контактные датчики
	#define PIN_SENSOR_SHIGHP   37  // [X4(S2)] Датчик высокого давления (X4.1 + X4.2)
	#define PIN_SENSOR_POWER	63	// [X24.1] Датчик наличия высокого напряжения, через делитель <--20кОм--БП12V--6.8кОм--GND[X24.2]
	#define PIN_SENSOR_GENERATOR 36	// [X3] Датчик работы от генератора - реле NO, (X3.1 + X3.2)
	//#define PIN_SENSOR_SLOWP      //         // Датчик низкого давления
	//#define PIN_SENSOR_SERRFC   38  //[X5]     // Сигнал ошибка инвертора
	//#define PIN_SENSOR_SFLOWCON 39             // Датчик потока по кондесатору
	//#define PIN_SENSOR_SFLOWEVA 40             // Датчик потока по испарителю
	//#define PIN_SENSOR_SEVA     41             // Датчик протока по испарителю

	// Имена индексов ВАЖЕН ПОРЯДОК!
	#define SHIGHP            0        // Датчик высокого давления
	#define SPOWER            1        // Датчик наличия питания (220/380V)
	#define SGENERATOR        2        // Датчик работы от генератора
	//#define SLOWP             0        // Датчик низкого давления
	//#define SERRFC            1        // Сигнал ошибка инвертора

	  // Массив ног соглано индексов
	 const uint8_t pinsInput[INUMBER] = {
										   PIN_SENSOR_SHIGHP,         // Датчик высокого давления
										   PIN_SENSOR_POWER,			  // Датчик высокого давления
										   PIN_SENSOR_GENERATOR
										   //PIN_SENSOR_SLOWP,       // Датчик низкого давления
										   //PIN_SENSOR_SERRFC       // Сигнал ошибка инвертора
										 };
	  // Описание датчиков
	  const char *noteInput[INUMBER] = {
										 "Датчик высокого давления",      // аварийный
										 "Датчик наличия электричества",
										 "Работа от генератора"
									   //"Датчик низкого давления",       // аварийный
									   //"Сигнал ошибки Частотника"        // аварийный
									   };
	  // Имена датчиков
	  const char *nameInput[INUMBER] = {
										"SHIGHP",          // Датчик высокого давления
										"SPOWER",
										"SGEN"
									  //"SLOWP",            // Датчик низкого давления
									  //"SERRFC"           // Сигнал ошибка инвертора
									   };

	  const bool TESTINPUT[INUMBER]        = {   0,      1,       0 };   // Значения датчиков при тестировании  опция TEST
	  const bool ALARMINPUT[INUMBER]       = {   1,      0,       0 };   // Значение датчика для типа pALARM и для SGENERATOR
	  const TYPE_SENSOR SENSORTYPE[INUMBER] ={pALARM, pSENSOR, pSENSOR}; // тип контактного датчика  pALARM, pSENSOR,  pPULSE
	// ---------------------------------------------------------------------------------------------------------------------------------------
	// Частотные датчики ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
	#define FNUMBER				2       // Максимальное число частотных датчиков цифровые входы (то что поддерживается) код поддерживает 5 датчиков максимально!
	//  Ноги куда прицепленны контактные датчики - разъемы X7 и X8 перепаяны под 12V!
	#define PIN_SENSOR_FLOWEVA   40     // X7(S5). Датчик потока по испарителю
	#define PIN_SENSOR_FLOWCON   41     // X8(S6). Датчик потока по кондесатору
	// SIKA VVX25: +12V - коричневый (Xn.2), GND - голубой (Xn.3), выход - черный (Xn.1)
	// НЕ ПОДКЛЮЧЕН:
	//  #define PIN_SENSOR_FLOWPCON  68   // Датчик протока предконденсатора
	// Имена индексов ВАЖЕН ПОРЯДОК!
	#define FLOWEVA				0        // Датчик потока по испарителю
	#define FLOWCON				1        // Датчик потока по кондесатору
	//#define FLOWPCON			2        // Датчик протока по предконденсатору
	// Массив ног соглано индексов
	const uint8_t pinsFrequency[FNUMBER] = { PIN_SENSOR_FLOWEVA,      // Датчик потока по испарителю
											 PIN_SENSOR_FLOWCON     // Датчик потока по кондесатору
	//                                         ,PIN_SENSOR_FLOWPCON     // Датчик протока по предконденсатору
										   };
	// Описание датчиков
	const char *noteFrequency[FNUMBER] = { "Проток геоконтура (м³ч)",      // Датчик потока по испарителю
										   "Проток отопления (м³ч)"        // Датчик потока по кондесатору
	//                                       ,"Датчик протока по предконденсатору (кубы/час)" //  Датчик протока по предконденсатору
										};
	  // Имена датчиков
	const char *nameFrequency[FNUMBER] = {  "FLOWEVA",        // Датчик потока по кондесатору
											"FLOWCON"         // Датчик потока по кондесатору
	//                                         ,"FLOWPCON"       // Датчик протока по предконденсатору
										   };
	// не забываем настраивать массивы под число датчиков
	const uint16_t TRANSFLOW[FNUMBER]= {10000,  10000};   // Коэффициент преобразования частота - поток, сотые
	const uint16_t TESTFLOW[FNUMBER] = { 2000,   1500};   // Значения датчиков при тестировании  опция TEST
	const uint8_t  MINFLOW[FNUMBER] =  {    4,      3};   // МИНИМАЛЬНЫЕ Значения датчиков, десятые m3
	#define FLOW_CONTROL								  // Контроль потоков через ПТО (актуален если установлены расходомеры)

	// АНАЛОГОВЫЕ ДАТЧИКИ  -------------------------------------------------------------------
	#define ANUMBER		5       // Максимальное число аналоговых датчиков (то что поддерживается)
	// наличие датчиков в конфигурации минимальные максимальные и тестовые значения
	// Справочно нумерация датчиков
	// Давление харится в сотых бара
	#define PEVA			0	// Датчик давления испарителя.
	#define PCON			1	// Датчик давления конденсатора.
	#define PGEO			2	// Датчик давления жидкости геоконтура
	#define POUT			3	// Датчик давления теплоносителя отопления
	#define IWR				4	// Датчки тока на входе ваттроутера, должен быть последним!
	// Имена датчиков
	const char *nameAnalog[] = {"PEVA",
								"PCON",
								"PGEO",
								"POUT",
								"IWR"
						   };
	// Описание датчиков
	const char *noteAnalog[] = {"Давление кипения",
								"Давление конденсации",
								"Давление геоконтура",
								"Давление отопления",
								"Ток ваттроутера"
							};

	// Номера каналов АЦП, в нумерации SAM3X (AD*):
	#define ADC_SENSOR_PEVA		13		// A11, X33. датчик давления испарителя
	#define ADC_SENSOR_PCON		12		// A10, X31. датчик давления конденсатора
	#define ADC_SENSOR_PGEO		4		// A3, X19.1 датчик давления геоконтура - желтый, красный "+5V", черный "-".
	#define ADC_SENSOR_POUT		5		// A2, X16.3 датчик давления отопления - желтый, красный "+5V", черный "-".
	#define ADC_SENSOR_IWR		3		// A4, X19.2 датчик тока (4-20мА), + резистор 150 Ом на GND
	// Коэффициент преобразования отсчеты АЦП-давление, тысячные
	const uint16_t TRANsADC[ANUMBER]  = {   373, 1380,  181,  181, 1000};
	// напряжение (отсчеты АЦП) соответсвующее cZero
	const uint16_t ANALOG_ZERO[ANUMBER] = { 290,  740,   70,   70,    0};
	// Усиление на шине (0,1 = x1, 2 = x2, 3 = x4)
	// const uint8_t  ADC_GAIN[ANUMBER] = { 1,    1,    1,    1};


	const boolean ANALOG_SENSORS[ANUMBER]= { true,  true, true, true, true};	// Присутствие датчика в конфигурации
	const int16_t ANALOG_MIN[ANUMBER]   = {   30,   100,  100,  100,-32767};	// минимальные значения, в сотых
	const uint16_t ANALOG_MAX[ANUMBER]  = {  700,  2000,  280,  280,65535};	// Максимальные значения, в сотых
	const uint16_t ANALOG_TEST[ANUMBER] = {  150,   800,  150,  150,    1};	// Значения датчиков при тестировании  опция TEST, в сотых
	//#define ANALOG_MODBUS 									// Данные аналоговых датчиков читаются по Modbus RTU
	#ifdef ANALOG_MODBUS
	#define ANALOG_MODBUS_NUM_READ				3			// Число попыток чтения
	#define ANALOG_MODBUS_ERR_DELAY				50			// Задержка при ошибки чтения
	const uint16_t ANALOG_MODBUS_ADDR[ANUMBER] = { 1, 1 };	// Адрес устройства Модбас, если 0, то датчик обычный.
	const uint16_t ANALOG_MODBUS_REG[ANUMBER]  = { 60, 59 };	// Регистр Модбас, по которому доступно значение датчика. Для Vacon=(AI2, AI1)
	#endif
	// ------------------- ADC SENSOR ----------------------------------
	#define ADC_PRESCAL		9			// = (42 / ADCClockMhz - 1), - 4.2 MHz
	#define ADC_SKIP_EXTREMUM 300		// Отбрасывать максимумы/минимумы больше заданной дельты
	#define P_NUMSAMLES       1			// Число значений для усреднения показаний давления
	#define ADC_FREQ          3			// период опроса аналоговых датчиков в секунду
	#define FILTER_SIZE       50		// Длина фильтра для датчиков давления
	#define FILTER_SIZE_OTHER 4			// Длина фильтра для остальных датчиков

	//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Исполнительные устройства (реле и сухие контакты) ВНИМАТЕЛЬНО ПРОВЕРЯЕМ СООТВЕТСВИЕ ВСЕХ МАССИВОВ!!! ------------------------------------------------------------------
	#define RELAY_INVERT			// Реле выходов: включение высоким уровнем (High Level trigger)
	#define RNUMBER                    12 // Число исполнительных устройств (всех)
	// устройства DC 24V
	#define PIN_DEVICE_RCOMP           12 //{#->61,X22.2}[R_9(X1)3.3V] через FOD852(p1..4); X174.2->p2, X1.2->R680->(p1): 24V(6)->p4, DI1(8)->p3. Реле включения компрессора. P5.1=1
	//#define PIN_FC_RESET             53 //[R_7] -> DI3(10) Выход для сброса инвертора
	// устройства DC 12V
	#define PIN_DEVICE_GEN             62 // X22.3 -> R680 -> FOD852.p1, X12.1(GND) -> FOD852.p2 (FOD852 = TLP627)
	// устройства DC 5V
	#define PIN_DEVICE_BATH_HEATER     33 // X37.2(EEV23) -> Relay(-12V)(+12V=X38.1) -> подает DA9(5V) -> провод -> реле 5V -> пускатель нагревателя
	// устройства AC 220V
	#define PIN_DEVICE_RPUMPO          47 //[R_2] Реле включения насоса выходного контура  (отопление и ГВС)
	#define PIN_DEVICE_RPUMPBH         48 //[R_3] Реле насоса НАГРЕВА бойлера (ГВС) - не циркуляция
	#define PIN_DEVICE_RPUMPI          49 //[R_4] Реле включения насоса входного контура  (геоконтур)
	#define PIN_DEVICE_RBOILER         13 //50 //{#->13} [R_5] Включение ТЭНа бойлера (SSR, PWM)
	#define PIN_DEVICE_R4WAY           51 //[R_6] 4-ходовой клапан
	#define PIN_DEVICE_RPUMPFL         50 //11 //{#->50}[R_8] реле насоса Теплого Пола
	#ifdef USE_SUN_COLLECTOR
		#define PIN_DEVICE_RSUN        46 //[R_1] Реле включения насоса солнечного коллектора
		#define PIN_DEVICE_RSUN_ON     53 //[R_7] Реле включение шарового крана солнечного коллектора
		#define PIN_DEVICE_RSUN_OFF    60 //13 //{#->60,X22.1}[R_10] Реле выключение шарового крана солнечного коллектора, через доп реле.
		#define SUN_VALVE_SWITCH_TIME  30000 // Время переключения крана, мсек
	#endif
	//	#define PIN_DEVICE_GEN             34 // X37.1(EEV23) -> Relay(-12V)(+12V=X41.2)
	//  #define PIN_DEVICE_RSUPERBOILER    11 //[R_8] реле насоса супербойлера
	//  #define PIN_DEVICE_RHEAT           12 //[R_9] Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.
	//    #define PIN_DEVICE_R3WAY         13 //[R_10(X2)3.3V] 3-ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
	//  #define PIN_DEVICE_RFAN1           11        // Реле включения вентилятора испарителя №1
	//  #define PIN_DEVICE_RFAN2           11        // Реле включения вентилятора испарителя №2
	//  #define PIN_DEVICE_REVI            11        // Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
	//                                     Пины DUE 68, 69 не подключены к плате!

	// Имена индексов ВАЖЕН ПОРЯДОК!
	#define RCOMP              0          // Реле включения компрессора (через пускатель)
	#define RPUMPO             1          // Реле включения насоса выходного контура  (отопление и/или ГВС)
	#define RPUMPBH            2          // Реле насоса НАГРЕВА бойлера (ГВС) - не путать с циркуляцией
	#define RPUMPI             3          // Реле включения насоса входного контура  (геоконтур)
	#define RBOILER            4          // Включение ТЭНа бойлера
	#define R4WAY              5          // 4-ходовой реверсивный клапан (охлаждение)
	#define RPUMPFL            6          // Реле насоса Теплого Пола
	#define RSUN			   7		  // Реле включения солнечного коллектора
	#define RBATH              8          // Реле включения отопителя ванной
	#define RSUNON             9          // Реле открытия шарового крана солнечного коллектора
	#define RSUNOFF            10         // Реле закрытия шарового крана солнечного коллектора
	#define RGEN               11         // Реле запуска генератора (ATS), так не дает остановить его, если он уже запущен
	//   #define RRESET             6          // Выход для сброса инвертора
	//   #define R3WAY              7          // Трех ходовой кран. Переключение системы СО — ГВС (что сейчас греть)
	//                                         // Если заремарен, то конфигурация с двумя насосами RPUMPO и RPUMPB. Работают по-очередно.
	//   #define RSUPERBOILER       6          // реле насоса супербойлера
	//   #define RFAN1              5          // Реле включения вентилятора испарителя №1
	//   #define RFAN2              6          // Реле включения вентилятора испарителя №2
	//   #define REVI               6          // Соленойд для EVI. (испаритель ниже +3гр и конденсатор выше +40гр)
	//   #define RHEAT              7          // Включение ТЭНа СО (электрокотел), может использоваться как догрев, резерв и т.д.

	#define PUMP_OUT      RPUMPO			// Насос выходного контура (отопление)
	#define PUMP_IN       RPUMPI 			// Насос входного  контура (гео или воздушник)

	//#define RELAY_WAIT_SWITCH	11			// Заморозить выполнение задач на это время после переключения реле, ms

	#define CORRECT_POWER220				// Корректировка потребляемой мощности из электросети (и для расчета COP), если включены указанные реле, Вт
	#ifdef CORRECT_POWER220
		CORRECT_POWER220_STRUCT correct_power220[] = { {RPUMPFL, 25} }; // Обороты: III = 45 Вт, II = 22 Вт, ТП-4 = 25
	#endif
	#define STATS_SKIP_COP_WHEN_RELAY_ON 	RBOILER	// Пропускать логирование COP при включенном реле

	// Массив ног соглано индексов
	const uint8_t pinsRelay[RNUMBER] = { PIN_DEVICE_RCOMP,       // ++ Реле включения компрессора (через пускатель)
										PIN_DEVICE_RPUMPO,      // ++ Реле включения насоса выходного контура  (отопление и ГВС)
										PIN_DEVICE_RPUMPBH,     // ++ Реле насоса НАГРЕВА бойлера (ГВС) - не путать с циркуляцией
										PIN_DEVICE_RPUMPI,      // ++ Реле включения насоса входного контура  (геоконтур)
										PIN_DEVICE_RBOILER,     // ++ Включение ТЭНа бойлера
										PIN_DEVICE_R4WAY,    	// ++ 4-ходовой реверсивный клапан
										PIN_DEVICE_RPUMPFL,      // Реле Теплого Пола
										PIN_DEVICE_RSUN,			// Реле включения солнечного коллектора
										PIN_DEVICE_BATH_HEATER,
										PIN_DEVICE_RSUN_ON,
										PIN_DEVICE_RSUN_OFF,
										PIN_DEVICE_GEN
									  };
	// Описание реле
	const char *noteRelay[RNUMBER] = { "Реле включения компрессора",
									 "Реле включения насоса отопления",
									 "Реле насоса нагрева бойлера",
									 "Реле включения насоса геоконтура",
									 "Реле включение ТЭНа бойлера",
									 "Реверсивный клапан",
									 "Реле насоса Теплого Пола",
									 "Реле насоса Солнечного Коллектора",
									 "Реле отопителя ванной",
									 "Реле открытия СК",
									 "Реле закрытия СК",
									 "Реле генератора"
								   };
	//  Имя реле
	const char *nameRelay[RNUMBER] = { "RCOMP",          // Реле включения компрессора
									 "RPUMPO",         // Реле включения насоса отопления
									 "RPUMPBH",        // Реле насоса НАГРЕВА бойлера (ГВС) - не путать с циркуляцией
									 "RPUMPI",         // Реле включения насоса геоконтура
									 "RBOILER",        // Реле включение ТЭНа бойлера
									 "R4WAY",           // 4-ходовой реверсивный клапан
									 "RPUMPFL",	       // Реле насоса ТП
									 "RSUN",			// Реле включения солнечного коллектора
									 "RBATH",
									 "RSUNON",
									 "RSUNOFF",
									 "RGEN"
								   } ;
	// #define R4WAY_INVERT     // Инвертирование четырехходового при этом получается: охлаждение - реле выключено, нагрев - включено (если дефайна нет то на оборот)

	// ДАТЧИКИ ТЕМПЕРАТУРЫ. СОТЫЕ ГРАДУСА ------------------------------------------------------------------------
	// наличие датчиков  датчиков от конфигурации минимальные максимальные и тестовые температуры
	// Температура хранится в сотых градуса
	// Нумерация датчиков
	// --------------------------------------------------------------------------------
	// ДАТЧИКИ и УСТРОЙСТВА - максимально поддерживаемые
	// --------------------------------------------------------------------------------
	#define TNUMBER     24      // Максимальное число температурных датчиков (то что поддерживается)
	//#define SENSOR_IP           // Использование удаленных устройств( датчиков температуры смотрим IPNUMBER )
	#define IPNUMBER    0       // Максимальное число удаленных датчиков, запрет использования: заремарить SENSOR_IP, IPNUMBER = 0
	#define RADIO_SENSORS_MAX 5

	#define TOUT        0    // Температура улицы                                - 100450B402080014
	#define TIN         1    // Температура в доме                               - -
	#define TBOILER     2    // Температура в бойлере ГВС                        - 289704C60400009B
	#define TCOMP       3    // Температура нагнетания компрессора               - 28FF235B63140298
	#define TEVAING     4    // Температура на входе ПТО геоконтура (по гликолю)     - 28E1962606000083
	#define TEVAOUTG    5    // Температура на выходе ПТО геоконтура (по гликолю)    - 2897E02606000058
	#define TCONING     6    // Температура на входе ПТО СО (по гликолю)   - 28B41A28060000B9
	#define TCONOUTG    7    // Температура на выходе ПТО СО (по гликолю)  - 28E6C1250600004A
	#define TEVAOUT     8    // Температура на выходе ПТО геоконтура (по фреону)     - 285960280600000A
	#define TCONOUT     9    // Температура на выходе ПТО СО (по фреону)   - 28FF509C55140355
	#define TSUN		10   // Температура солнечного коллектора (улица)        - 28FF22F9551403AA
	#define TSUNOUTG	11   // Температура на выходе из СК (гликоль)            - 28DE862E1713012C
	// Датчики для информации:
	#define TKITCHEN	12  // 101350B4020800CA
	#define TFL1BEDR	13  // 28C974DF050000CB
	#define TFL2BEDR	14  // 10DA24AC02080095
	//#define TBASEMENT	15  // 106023B402080028
	//#define TEOUT		16	// 102D74B302080055
	// Радиодатчики:
	//#define T65		17  // прихожая			(№65) 18136
	//#define T55		18  // Санузел			(№55) 18185
	//#define T38		19  // 1 этаж			(№38) 18130
	#define TFL2TV		20  // 2 этаж, ТВ		(№45) 18172
	//#define T49		21  // Баня				(№49) 18143
	#define TEVAIN      22  // Температура на входе ПТО геоконтура (по фреону)
	#define TCOMPIN     23  // Температура на входе компрессора

	// Отсутствующие датчики:
	//#define TCONIN      0   // Температура на входе конденсатора (по фреону)
	//#define TACCUM      0   // Температура на выходе теплоаккмулятора
	// Наличие датчика в конфигурации: 0 - нет, >0 - есть, +2(бит_1) - выводить датчик отдельно внизу на странице "схема ТН" (если бит_0 = 0 - то только когда привязан)
	//                                                     +4(бит_2) - Логировать при ошибках
	//...................................0.....1.....2.....3.....4.....5.....6.....7.....8.....9....10....11....12....13....14....15....16....17....18....19....20....21....22....23....
	const uint8_t SENSORTEMP[TNUMBER]={    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    7,    7,    7,    7,    4,    6,    6,    6,    6,    6,    1,    1 };
	// минимальные значения температур
	const int16_t MINTEMP[TNUMBER] = { -4000,-1000,-1000,-1000,-2000,-2000,-2000,-2000,-2000,-2000,-4000,-2000,-2000,-3000,-3000,-3000,-3000,-2000,-2000,-2000,-2000,-2000,-2000,-2000 };
	// Макимальные значения температур, ВНИМАНИЕ! для TBOILER температура меняется если включен режим сальмонеллы на SALLMONELA_TEMP+300
	const int16_t MAXTEMP[TNUMBER] = {  9000, 9000, 9000, 8700, 9000, 9000, 6000, 6500, 9000, 9000,10000, 9000, 9000, 9000, 9000, 9000, 9000, 7000, 7000, 7000, 7000, 7000, 9000, 9000 };
	// Значения датчиков при тестировании, опция TEST
	const int16_t TESTTEMP[TNUMBER]= {  1000, 2200, 6000, 5000,  500,  100, 3000, 3500, -200, 3300, 2700, 3500, 2000, 2100, 2200, 1500, 2150, 2301, 2302, 2303, 2304, 2305, 2800, -100 };
	// Ошибки датчиков (систематические) нужны для калибровки ОШИБКИ ДОБАВЛЯЮТСЯ!!! к значениям В СОТЫХ ГРАДУСА
	const int16_t ERRTEMP[TNUMBER]=  {     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0 };
	// Имена датчиков
	const char *nameTemp[TNUMBER] = {
		"TOUT",             // 0. Температура улицы
		"TIN",              // 1. Температура в доме
		"TBOILER",          // 2. Температура в бойлере ГВС
		"TCOMP",            // 3. Температура нагнетания компрессора
		"TEVAING",          // 4. Температура на входе испарителя по гликолю
		"TEVAOUTG",         // 5. Температура на выходе испарителя по гликолю
		"TCONING",          // 6. Температура на входе конденсатора по гликолю
		"TCONOUTG",         // 7. Температура на выходе конденсатора по гликолю
		"TEVAOUT",          // 8. Температура на выходе испарителя по фреону
		"TCONOUT",          // 9. Температура на выходе конденсатора по фреону

		"TSUN",				// 10. Температура солнечного коллектора (улица)
		"TSUNOUTG",			// 11. Температура на выходе из солнечного коллектора (гликоль)
		"TKITCHEN",			// 12.
		"TFL1BEDR",			// 13.
		"TFL2BEDR",			// 14.
		"TBASEMENT",		// 15.
		"TEOUT",			// 16.
		// Радиодатчики
		"T65",				// 17.
		"T55",				// 18.
		"T38",				// 19.
		"T45",				// 20.
		"T49",				// 21.
		"TEVAIN",			// 22.
		"TCOMPIN"			// 23.
	};
	// Описание датчиков
	const char *noteTemp[TNUMBER] = {
		"Температура улицы",
		"Температура в доме",
		"Температура в бойлере ГВС",
		"Температура нагнетания компрессора",
		"Температура на входе из геоконтура",
		"Температура на выходе в геоконтур",
		"Температура на входе из отопления",
		"Температура на выходе в отопление",
		"Температура фреона на выходе ПТО гео",
		"Температура фреона на выходе ПТО дома",
		"Температура солнечного коллектора (улица)",
		"Температура на выходе из солнечного коллектора",
		"Температура кухни",
		"Температура спальни 1 этажа",
		"Температура спальни 2 этажа",
		"Температура подвала",
		"Температура электрокотла",

		"Температура в прихожей",
		"Температура санузла",
		"Температура 1 этажа",
		"Температура 2 этажа, ТВ",
		"Температура пристройки",

		"Температура перед ЭРВ", //"Температура фреона на входе ПТО гео",
		"Температура на входе компрессора"
	};
	// #endif

	#define TIME_READ_SENSOR  2000         // Период опроса датчиков (мсек)
	#define T_NUMSAMLES       1             // Число значений для усреднения показаний температуры
	#define GAP_TEMP_VAL      500           // Допустимая разница (в сотых C) показаний между двумя считываниями (борьба с помехами) - при привышении ошибка не возникает, но данные пропускаются.
	#define GAP_TEMP_VAL_CRC  200     	  // Датчики с флагом игнорировать CRC. Допустимая разница (в сотых C) показаний между двумя считываниями (борьба с помехами) - при привышении ошибка не возникает, но данные пропускаются.
	#define GAP_NUMBER        3       	  // Максимальное число идущих подряд показаний превышающих на GAP_TEMP_VAL, после этого эти показания выдаются за действительные
	#define GAP_NUMBER_CRC    7       	  // Датчики с флагом игнорировать CRC. Максимальное число идущих подряд показаний превышающих на GAP_TEMP_VAL, после этого эти показания выдаются за действительные

	//
	// Конфигурация системы отопления --------------------------------------------------------------------------------
	// от куда брать температуру обратки и подачи системы отопления смотртеть кондесатор.
	// Могут быть задействованы разные датчики!
	#define FEED      sTemp[TCONOUTG].get_Temp()       // Подача системы CO
	#define RET       sTemp[TCONING].get_Temp()        // Обратка системы CO

	// Графики в памяти
	Charts_Mod_setup ChartsModSetup[] = {
		{ STATS_OBJ_Temp, TOUT },
		{ STATS_OBJ_Temp, TIN },
		{ STATS_OBJ_Temp, TBOILER },
		{ STATS_OBJ_Temp, TCOMP },
		{ STATS_OBJ_Temp, TEVAING },
		{ STATS_OBJ_Temp, TEVAOUTG },
		{ STATS_OBJ_Temp, TCONING },
		{ STATS_OBJ_Temp, TCONOUTG },
		{ STATS_OBJ_Temp, TEVAOUT },
		{ STATS_OBJ_Temp, TCONOUT },
		{ STATS_OBJ_Temp, TSUN },
		{ STATS_OBJ_Temp, TSUNOUTG },
		{ STATS_OBJ_Flow, FLOWEVA },
		{ STATS_OBJ_Flow, FLOWCON },
		//{ STATS_OBJ_Press, PGEO },
		{ STATS_OBJ_Press, POUT },
		{ STATS_OBJ_PressTemp, PEVA },
		{ STATS_OBJ_PressTemp, PCON }
	};
	const Charts_Const_setup ChartsConstSetup[] = {
		{ STATS_OBJ_EEV, "ЭРВ" },
		{ STATS_OBJ_Overheat, "Перегрев" },
		{ STATS_OBJ_Overheat2, "Перегрев на входе компрессора" },
		{ STATS_OBJ_Compressor, "Частота, Гц" },
		//{ STATS_OBJ_Power_FC, "Мощность компрессора" },
		{ STATS_OBJ_Power, "Потребляемая мощность" },
		{ STATS_OBJ_COP_Full, "COP" }
	};
	const Charts_Const_setup ChartsOnFlySetup[] = {
		{ STATS_OBJ_Overcool, "Переохлаждение" }, // T[PCON] - TCONOUT
		{ STATS_OBJ_TCOMP_TCON, "Нагнетание - Конденсация" }, // TCOMP - TCON
		{ STATS_OBJ_Delta_GEO, "Дельта температур геоконтура" }, // TEVAING - TEVAOUTG
		{ STATS_OBJ_Delta_OUT, "Дельта температур выхода" }, // TCONOUTG - TCONING
		{ STATS_OBJ_Power_GEO, "Мощность геоконтура" }, // (TEVAOUTG - TEVAING) * FLOWEVA / kfCapacity
		{ STATS_OBJ_Power_OUT, "Выходная мощность" } // (TCONOUTG - TCONING) * FLOWCON / kfCapacity
	};

	// История (графики) на SD карте
	const History_setup HistorySetup[] = {
		{ STATS_OBJ_Compressor, 0, "Компрессор, Гц" },
		{ STATS_OBJ_Temp, TOUT, noteTemp[TOUT] },
		{ STATS_OBJ_Temp, TIN, noteTemp[TIN] },
		{ STATS_OBJ_Temp, TBOILER, noteTemp[TBOILER] },
		{ STATS_OBJ_Temp, TCOMP, noteTemp[TCOMP] },
		{ STATS_OBJ_Temp, TEVAING, noteTemp[TEVAING] },
		{ STATS_OBJ_Temp, TEVAOUTG, noteTemp[TEVAOUTG] },
		{ STATS_OBJ_Temp, TCONING, noteTemp[TCONING] },
		{ STATS_OBJ_Temp, TCONOUTG, noteTemp[TCONOUTG] },
		{ STATS_OBJ_Temp, TEVAOUT, noteTemp[TEVAOUT] },
		{ STATS_OBJ_Temp, TCONOUT, noteTemp[TCONOUT] },
		{ STATS_OBJ_Temp, TSUN, noteTemp[TSUN] },
		{ STATS_OBJ_Temp, TSUNOUTG, noteTemp[TSUNOUTG] },
		{ STATS_OBJ_PressTemp, PEVA, "Температура кипения" },
		{ STATS_OBJ_PressTemp, PCON, "Температура конденсации" },
		{ STATS_OBJ_Flow, FLOWEVA, noteFrequency[FLOWEVA] },
		{ STATS_OBJ_Flow, FLOWCON, noteFrequency[FLOWCON] },
		{ STATS_OBJ_EEV, STATS_EEV_Percent, "Положение ЭРВ, %" },
		{ STATS_OBJ_EEV, STATS_EEV_OverHeat, "Перегрев" },
		{ STATS_OBJ_EEV, STATS_EEV_OverCool, "Переохлаждение" },
		{ STATS_OBJ_Power, 0, "Потребление, кВт" },
		{ STATS_OBJ_Power_OUT, 0, "Выработка, кВт" },
		{ STATS_OBJ_COP_Full, 0, "COP" },
		{ STATS_OBJ_Temp, TKITCHEN, noteTemp[TKITCHEN] },
		{ STATS_OBJ_Temp, TFL2BEDR, noteTemp[TFL2BEDR] },
		{ STATS_OBJ_Temp, TFL2TV, noteTemp[TFL2TV] }
	};

	#define PID_FORMULA2							// Адаптированный алгоритм ПИД Arduino-PID-Library
	// ------------------- EEV -----------------------------------
	// ЭРВ ТОЛЬКО ОДНА ШТУКА ВСЕГДА (не массив) ------------------
	#define EEV_DEF                     // Наличие ЭРВ в конфигурации
	#ifdef EEV_DEF                                  // ЭРВ настройки
	#define EEV_PREFER_PERCENT					  // Предпочтительно положение ЭРВ в %. (Для графиков и т.п.)
	#define EEV_STEPS              480            // Число шагов ЭРВ 480
	#define EEV_CLOSE_STEP         0              // ЭРВ закрыт
	#define EEV_QUEUE              10             // Длина очереди команд шагового двигателя ЭРВ
	#define EEV_PHASE              PHASE_8s       // ЗАДАННАЯ (можно менять) последовательность (шагов) при движении ЭРВ
	#define EEV_SET_ZERO_OVERRIDE  8			  // Добавка к полному закрытию при установке нуля, шаги
	#define EEV_OVERHEAT2_CRITICAL 30             // Критическое значение перегрева 2, сотые градуса
	//#define EEV_INVERT                          // Признак инвертирования движения ЭРВ  (меняем если крутит в обратную сторону)
	//#define EEV_MIN_CONTROL                     // Контроль нижней границы ЭРВ - останов по ошибке.
	//#define EEV_MAX_CONTROL                     // Контроль верхней границы ЭРВ - останов по ошибке.

	#define FREON                  R134A 		  // Тип фреона
	// Значения по умолчанию
	#define DEFAULT_RULE_EEV       TEVAOUT_PEVA	  // Формула по умолчанию - TEVAOUT_PEVA
	#define DEFAULT_EEV_TIME	   8			  // Постоянная интегрирования времени в секундах ЭРВ СЕКУНДЫ
	#define DEFAULT_OVERHEAT       125			  // Перегрев по умолчанию (сотые градуса)
	#define DEFAULT_EEV_Kp	       200			  // ПИД Коэф пропорц.  В СОТЫХ
	#define DEFAULT_EEV_Ki	       50			  // ПИД Коэф интегр.   В СОТЫХ
	#define DEFAULT_EEV_Kd	       500			  // ПИД Коэф дифф.   В СОТЫХ
	#define DEFAULT_ERR_KP         100.0          // Ошибка (в сотых градуса) при которой происходит уменьшение пропорциональной составляющей ПИД ЭРВ
	#define DEFAULT_SPEED_EEV      31             // Скорость шагового двигателя ЭРВ (импульсы в сек.)
	#define DEFAULT_PRE_START_POS  300            // ПУСКОВАЯ позиция ЭРВ (ТО что при старте компрессора ПРИ РАСКРУТКЕ)
	#define DEFAULT_START_POS      240            // СТАРТОВАЯ позиция ЭРВ после раскрутки компрессора т.е. ПОЗИЦИЯ С КОТОРОЙ НАЧИНАЕТСЯ РАБОТА проходит DelayStartPos сек
	#define DEFAULT_HOLD_MOTOR     false          // Режим "удержания" шагового двигателя ЭРВ
	// Корректировки для фреона R134a
	#define DEF_OHCor_OverHeatStart 	100		  	// Начальный перегрев (сотые градуса)
	#define DEF_OHCor_OverHeatMin 		50    		// Минимальный перегрев (сотые градуса)
	#define DEF_OHCor_OverHeatMax 		250    		// Максимальный перегрев (сотые градуса)
	#define DEF_OHCor_TDIS_TCON			1160        // Разница температура нагнетания - конденсации(при 30С) и 0С кипении и перегреве OHCor_OverHeatStart (в сотых)
	//#define DEF_OHCor_TDIS_TCON_Thr 	300		    // Порог, после превышения TDIS_TCON + TDIS_TCON_Thr начинаем уменьшать перегрев (в сотых)
	#define DEF_OHCor_CONDENSING_30_MUL 220			// Корректировка разницы Нагнетание-Конденсация на кажлые 10 градусов конденсации от 30 (в сотых), зависит от фреона
	#define DEF_OHCor_EVAPORATING_0_MUL 460			// Корректировка разницы Нагнетание-Конденсация на кажлые -10 градусов кипения от 0 (в сотых), зависит от фреона
	#define DEF_OHCor_Delay 			300         // Задержка после старта компрессора, сек
	#define DEF_OHCor_Period 			10		    // Период в циклах ЭРВ, сколько пропустить
	#define DEF_OHCor_MAX_STEP			200			// Максимальное изменение перегрева за раз, в сотых градуса

	// ЭРВ Времена и задержки
	#define DEFAULT_DELAY_ON_PID    30            // Задержка начала регулирования от пуска компрессора, сек. Общее время =delayOnPid+DelayStartPos
	#define DEFAULT_DELAY_ON        2             // Задержка между открытием (для старта) ЭРВ и включением компрессора, для выравнивания давлений (сек). Если ЭРВ закрывлось при остановке
	#define DEFAULT_DELAY_START_POS 5             // Время после старта компрессора когда EEV выходит на стартовую позицию - облегчение пуска вначале ЭРВ
	#define DEFAULT_DELAY_OFF       0             // Задержка закрытия EEV после выключения насосов (сек). Время от команды стоп компрессора до закрытия ЭРВ = delayOffPump+delayOff
	#endif

	// Частотный преобразователь ТОЛЬКО ОДНА ШТУКА ВСЕГДА (не массив) --------------------------------------------------------
	const boolean DEVICEFC=true;  // Наличие Частотного преобразователя в конфигурации
	#define FC_VACON        // Частотник Vacon
	// Настройка, параметр(регистр Modbus):
	// Vacon 10/20: V2.2 = 1; V2.3 = 1; V2.4 = 1; P2.1(172) = 0; P3.3(173) = 3; P5.1(403) = 1;
	//				Мин.частота: P3.1(101) = 4000; Макс.частота: P3.2(102) = 7000
	// Vacon 20: P10.8(859) = 8
	// Константы частотного преобразователя для конкртеной  реализации
	//#define FC_CORRECT_NOMINAL_POWER -70			// Корректировка расчетной номинальной мощности по ячейкам модбас = [#110] * [#113] * [#120] * 173/1000000, Вт
	#define FC_USE_RCOMP                            // Использовать для разрешения работы инвертора отдельный выход RCOMP (Vacon FB 172=0)
													// Используется дискретный вход частотника (0..30V), прописанный в ячейке P5.7 "Работа разрешена" (modbus #407)
	//#define FC_ANALOG_CONTROL						// Использование аналогового управления частотником, Для использования 485 закоментировать эту строку
	//#define PIN_DEVICE_FC			 2  			// Выход PWM или DACx
	//#define FC_ANALOG_OFF_SET_0					// Устанавливать выход PIN_DEVICE_FC в 0 при останове компрессора
	//#define FC_ANALOG_RESOLUTION   8				// Bit (8..12)
	// Значения по умолчанию (начало DEF_) не Константы
	#define DEF_FC_UPTIME            (5)            // Время обновления алгоритма пид регулятора (сек) Основной цикл управления
	#define DEF_FC_DT_COMP_TEMP      (5*100)        // Защита по температуре компрессора - сколько градусов не доходит до максимальной (TCOMP) и при этом происходит уменьшение частоты
	#define DEF_FC_PID_FREQ_STEP     (2*100)        // Максимальный шаг (на увеличение) изменения частоты при ПИД регулировании в 0.01 Гц Необходимо что бы ЭРВ успевал
	#define DEF_FC_PID_STOP          90             // Проценты от уровня защит (мощность, ток, давление, темпеартура) при которой происходит блокировка роста частоты пидом
	#define DEF_FC_PID_P_ON_M        false		    // Режим ПИДа отопления, бойлера - true пропорционально измерению, false - пропорционально ошибке
	#define DEF_FC_START_FREQ        (30*100)       // Стартовая скорость инвертора (см компрессор) в 0.01 %
	#define DEF_FC_START_FREQ_BOILER (30*100)       // Стартовая скорость инвертора (см компрессор) в 0.01 % ГВС
	#define DEF_FC_MIN_FREQ          (10*100)       // Минимальная  скорость инвертора (см компрессор) в 0.01 %
	#define DEF_FC_MIN_FREQ_COOL     (10*100)       // Минимальная  скорость инвертора при охлаждении в 0.01 %
	#define DEF_FC_MIN_FREQ_BOILER   (10*100)       // Минимальная  скорость инвертора при нагреве ГВС в 0.01 %
	#define DEF_FC_MIN_FREQ_USER     (1*100)        // Минимальная  скорость инвертора РУЧНОЙ РЕЖИМ (см компрессор) в 0.01 %
	#define DEF_FC_MAX_FREQ          (60*100)       // Максимальная скорость инвертора (см компрессор) в 0.01 %
	#define DEF_FC_MAX_FREQ_COOL     (30*100)       // Максимальная скорость инвертора в режиме охлаждения  в 0.01 %
	#define DEF_FC_MAX_FREQ_BOILER   (30*100)       // Максимальная скорость инвертора в режиме ГВС в 0.01 Гц поглощение бойлера обычно меньше чем СО
	#define DEF_FC_MAX_FREQ_USER     (150*100)      // Максимальная скорость инвертора РУЧНОЙ РЕЖИМ (см компрессор) в 0.01 %
	#define DEF_FC_STEP_FREQ         (2*100)        // Шаг уменьшения инвертора при достижении максимальной температуры, мощности и тока (см компрессор) в 0.01 %
	#define DEF_FC_STEP_FREQ_BOILER  (2*100)        // Шаг уменьшения инвертора при достижении максимальной температуры, мощности и тока ГВС в 0.01 %
	#define DEF_FC_DT_TEMP           (1*100)        // Привышение температуры от уставок (подача) при которой срабатыват защита (уменьшается частота) в сотых градуса
	#define DEF_FC_DT_TEMP_BOILER    (2*100)        // Привышение температуры от уставок (подача) при которой срабатыват защита ГВС в сотых градуса
	// КОНСТАНТЫ
	#define FC_DT_CON_PRESS           50            // Защита по давлению компрессора - сколько сотых бара не доходит до максимальной (PCON) и при этом происходит уменьшение частоты
	#define FC_MAX_POWER             (4000)         // Максимальная мощность инвертора (см компрессор) в Вт
	#define FC_MAX_POWER_BOILER      (4000)         // Максимальная мощность инвертора в режиме ГВС (см компрессор) в Вт
	#define FC_MAX_CURRENT           (10*100)       // Максимальный ток инвертора (см компрессор) в 0.01 А
	#define FC_MAX_CURRENT_BOILER    (10*100)       // Максимальный ток инвертора для ГВС в 0.01 А
	#define FC_ACCEL_TIME			 (2100)			// Время разгона компрессора в сотых сек
	#define FC_DEACCEL_TIME          (1100)   	  	// Время торможения компрессора в сотых сек
	#define FC_START_PID_DELAY       (30*100)      	// Задержка ПИД после старта компрессора

	#define FC_RETOIL_FREQ			  4500		    // Частота меньше которой должен происходить возврат масла, в сотых Гц
	#define FC_RETOIL_TIME			 (16/(FC_TIME_READ/1000)) // Время возврата, сек

	#define COP_ALL_CALC   // Проводить расчет КОП всегда, если дефайна нет, то КОП считается ТОЛЬКО при работающем компрессоре, в паузах ставится 0

	// Временные задержки (опции) Значения по умолчанию (начало DEF_)
	#define DEF_DELAY_ON_PUMP    	  	15             // Задержка включения компрессора после включения насосов (сек).
	#define DEF_DELAY_OFF_PUMP    		90             // Задержка выключения насосов после выключения компрессора (сек).
	#define DEF_DELAY_START_RES   		(5*60)         // Задержка включения ТН после внезапного сброса контроллера (сек.)
	#define DEF_DELAY_REPEAD_START 		(10*60)        // Задержка перед повторным включениме ТН при ошибке (попытки пуска) секунды
	#define DEF_DELAY_DEFROST_ON 		120            // ДЛЯ ВОЗДУШНОГО ТН Задержка после срабатывания датчика перед включением разморозки (секунды)
	#define DEF_DELAY_DEFROST_OFF		120            // ДЛЯ ВОЗДУШНОГО ТН Задержка перед выключением разморозки (секунды)
	#define DEF_DELAY_R4WAY        		20             // Задержка между переключением 4-х ходового клапана и включением компрессора, для выравнивания давлений (сек). Если включены эти опции (переключение тепло-холод)
	#define DEF_DELAY_BOILER_SW   		15             // Пауза (сек) после переключение ГВС - выравниваем температуру в контуре отопления/ГВС что бы сразу защиты не сработали
	#define DEF_DELAY_BOILER_OFF 		30             // Время (сек) на сколько блокируются защиты при переходе с ГВС на отопление и охлаждение слишком горяче после ГВС
	#define DELAY_AFTER_SWITCH_RELAY    250            // Задержка после переключения реле, для сглаживания потребления и уменьшения помех(мс)
	#define DELAY_BEFORE_STOP_IN_PUMP	15			   // Задержка перед выключением насоса геоконтура, насос отопления отключается позже (сек)

	//#define NOT_RESTART_ON_CRITICAL_ERRORS			// Не пытаться перезапустить ТН после этих ошибок

	#define INDEX_FILE					"plan.html"		// стартовый файл по умолчанию для веба
	//#define WEB_STATUS_SHOW_VERSION					// Показывать версию в строке статуса (запрос get_status)
	//#define WEB_STATUS_SHOW_OVERHEAT					// Показывать перегрев в строке статуса (запрос get_status)
	#define FORMAT_DATE_STR_CUSTOM
	const char *FORMAT_DATE_STR	 		= { "%02d.%02d.%04d" };
	#define HTTP_TIME_REQUEST			// Запрос времени по HTTP протоколу с собственного сервера (текстовый файл формата: "<время UTC>;").
										// У меня берется с электросчетчика Меркурий 231 АТ через подключенный к нему esp8266 (http://vad-7.blogspot.com/2017/03/mercury231.html)
	#ifdef HTTP_TIME_REQUEST
	const char HTTP_TIME_REQ[]			= "/curr_time.csv";
	#endif
	#define HTTP_LowConsumeServer		"192.168.0.8"
	#define HTTP_LowConsumeRequest		"/&LowConsume_set="			// HTTP GET запрос информирование о режиме низкого потребления, в конец будет добавлен 0/1

	// Ваттроутер (перенаправление свободной энергии солнца на нагрев)
	#define WATTROUTER												// Включить
	#define WR_NumLoads				4								// Кол-во нагрузок (0..5)
//	#define WR_CurrentSensor_4_20mA	IWR								// Использовать аналоговый датчик тока с выходом 4-20mA, номер ADC датчика
#ifndef TEST_BOARD
	const int8_t WR_Load_pins[]	=	{ PIN_DEVICE_RBOILER, 33, -1, -3 };	// [<0] - реле по HTTP, для PWM нагрузки пины должны быть PWM/TIMER
#else
	const int8_t WR_Load_pins[]	=	{ PIN_DEVICE_RBOILER, -2, -1, -3 };	// [<0] - реле по HTTP, для PWM нагрузки пины должны быть PWM/TIMER
#endif
	#define WR_Load_pins_Boiler_INDEX 0								// Индекс бойлера в массиве WR_Load_pins
	#define WR_RELAY_LEVEL_ON		1
	#define PWM_WRITE_OUT_FREQUENCY	3								// Частота вывода PWM, Гц, для функции PWM_Write()
	#define PWM_WRITE_OUT_RESOLUTION 5								// 0..31, bits
#ifndef WR_CurrentSensor_4_20mA
	#define WR_PNET_AVERAGE			5								// Размер буфера для усреднения
#endif
	#define WR_SKIP_EXTREMUM		200								// Отбрасывать пиковое значение больше Вт
	#define WR_NEXT_TURN_ON_PAUSE	10								// Минимальная пауза на включение следующего реле, сек

	#define HTTP_MAP_Server			"192.168.0.9"					// Адрес системы мониторинга Malina2 инвертора МАП МикроАрт
	#define HTTP_MAP_Read_MAP		"/read_json.php?device=map"		// Запрос чтения массива данных МАП
	#define HTTP_MAP_Read_MPPT		"/read_json.php?device=mppt"	// Запрос чтения массива данных КЭС
	#define HTTP_MAP_RELAY_SW_1		"/write_sec.php?id=1&relay="	// 1..3
	#define HTTP_MAP_RELAY_SW_2		"&mode="						// On = 1, Off = 0

#ifdef WR_CurrentSensor_4_20mA
	#define WEB0_FREQUENT_JOB_PERIOD 	1000	 		// Периодичность важных функций в задаче WEB0, мс
#else
	#define WEB0_FREQUENT_JOB_PERIOD 	1200	 		// Периодичность важных функций в задаче WEB0, мс
#endif
	#define WEB0_OTHER_JOB_PERIOD    	10000   		// Периодичность других функций внутри задачи WEB0, мс


#endif  // CONFIG_7

  
#endif
